import { tokenize, TokenType } from './tokenizer';
import { Stream } from './stream';
import { isParserError, ParserError, ErrorMsg } from './error';
import { ParserContext } from './parser-context';
import { ExpressionParser, Precedence } from './pratt-parser';
export var NodeType;
(function (NodeType) {
    NodeType[NodeType["FUNCTION_CALL"] = 0] = "FUNCTION_CALL";
    NodeType[NodeType["IDENTIFIER"] = 1] = "IDENTIFIER";
    NodeType[NodeType["LITERAL"] = 2] = "LITERAL";
    NodeType[NodeType["PREFIX_OPERATOR"] = 3] = "PREFIX_OPERATOR";
    NodeType[NodeType["BINARY_OPERATOR"] = 4] = "BINARY_OPERATOR";
    NodeType[NodeType["GROUP"] = 5] = "GROUP";
})(NodeType || (NodeType = {}));
export function children(node) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR: return [node.firstArgument, node.secondArgument];
        case NodeType.FUNCTION_CALL: return [node.argument];
        case NodeType.IDENTIFIER: return [];
        case NodeType.LITERAL: return [];
        case NodeType.PREFIX_OPERATOR: return [node.argument];
        case NodeType.GROUP: return [node.argument];
    }
}
export function toDebugString(node) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR:
            return "[" + toDebugString(node.firstArgument) + " " + node.token.value + " " + toDebugString(node.secondArgument) + "]";
        case NodeType.FUNCTION_CALL: return "[" + toDebugString(node["function"]) + "(" + toDebugString(node.argument) + ")]";
        case NodeType.IDENTIFIER: return "[" + node.token.value + "]";
        case NodeType.LITERAL: return "[" + node.token.value + "]";
        case NodeType.PREFIX_OPERATOR: return "[" + node.token.value + " " + toDebugString(node.argument) + "]";
        case NodeType.GROUP: return "[( " + toDebugString(node.argument) + " )]";
    }
}
export function forEachNode(node, callback) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR: {
            forEachNode(node.firstArgument, callback);
            forEachNode(node.secondArgument, callback);
            break;
        }
        case NodeType.IDENTIFIER:
        case NodeType.LITERAL: {
            break;
        }
        case NodeType.FUNCTION_CALL:
        case NodeType.PREFIX_OPERATOR:
        case NodeType.GROUP: {
            forEachNode(node.argument, callback);
            break;
        }
    }
    callback(node);
}
export function parseExpression(source) {
    source = source.trim();
    if (source.length === 0) {
        return {
            expression: null,
            userReadableError: ''
        };
    }
    var tokens = null;
    try {
        tokens = new Stream(tokenize(source));
    }
    catch (err) {
        if (isParserError(err)) {
            return {
                expression: null,
                userReadableError: err.message
            };
        }
    }
    var ctx = new ParserContext(tokens);
    var parser = new ExpressionParser(ctx);
    parser.registerTerminal(TokenType.INT_LITERAL, function (token) {
        return {
            type: NodeType.LITERAL,
            token: token
        };
    });
    parser.registerTerminal(TokenType.FLOAT_LITERAL, function (token) {
        return {
            type: NodeType.LITERAL,
            token: token
        };
    });
    parser.registerTerminal(TokenType.IDENTIFIER, function (token) {
        return {
            type: NodeType.IDENTIFIER,
            token: token
        };
    });
    parser.registerPrefixUnaryOperator(TokenType.PLUS);
    parser.registerPrefixUnaryOperator(TokenType.MINUS);
    parser.registerInfixBinaryOperator(TokenType.PLUS, Precedence.SUM);
    parser.registerInfixBinaryOperator(TokenType.MINUS, Precedence.SUM);
    parser.registerInfixBinaryOperator(TokenType.MULTIPLY, Precedence.PRODUCT);
    parser.registerInfixBinaryOperator(TokenType.DIVIDE, Precedence.PRODUCT);
    parser.registerInfixBinaryOperator(TokenType.POW, Precedence.EXPONENT);
    parser.registerParseletPrefix(TokenType.LEFT_PAREN, function (parser, _) {
        var peek = parser.peek();
        if (peek && peek.value === ')') {
            throw new ParserError(ErrorMsg.emptyParens);
        }
        var expr = parser.parseExpression(Precedence.LOWEST);
        if (!expr) {
            throw new ParserError(ErrorMsg.genericFailure);
        }
        if (!parser.consumeIfPresent(TokenType.RIGHT_PAREN)) {
            throw new ParserError(ErrorMsg.missingRightParen);
        }
        return {
            type: NodeType.GROUP,
            token: null,
            argument: expr
        };
    });
    parser.registerParseletInfix(TokenType.LEFT_PAREN, Precedence.CALL, function (parser, left, _) {
        var children = [];
        children.push(left);
        var expr = parser.parseExpression(Precedence.LOWEST);
        if (!expr) {
            throw new ParserError(ErrorMsg.invalidArgument(left.token.value));
        }
        if (!parser.consumeIfPresent(TokenType.RIGHT_PAREN)) {
            throw new ParserError(ErrorMsg.missingRightParen);
        }
        if (left.type !== NodeType.IDENTIFIER) {
            throw new ParserError(ErrorMsg.nonIdentifierFunctionName);
        }
        return {
            type: NodeType.FUNCTION_CALL,
            token: null,
            "function": left,
            argument: expr
        };
    });
    var expression = null;
    var userReadableError = null;
    try {
        expression = parser.parseExpression(Precedence.LOWEST);
    }
    catch (err) {
        if (isParserError(err)) {
            userReadableError = err.message;
        }
        else {
            userReadableError = ErrorMsg.genericFailure;
        }
    }
    if (!userReadableError && ctx.hasMoreTokens()) {
        userReadableError = ErrorMsg.genericFailure;
    }
    if (userReadableError != null) {
        return { expression: null, userReadableError: userReadableError };
    }
    return {
        expression: expression,
        userReadableError: userReadableError
    };
}
