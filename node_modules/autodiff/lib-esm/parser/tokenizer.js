import { ParserError, ErrorMsg } from './error';
import { supportedFunctions } from '../code-generation/code-generator';
export var TokenType;
(function (TokenType) {
    TokenType[TokenType["NONE"] = 0] = "NONE";
    TokenType[TokenType["PLUS"] = 1] = "PLUS";
    TokenType[TokenType["MINUS"] = 2] = "MINUS";
    TokenType[TokenType["MULTIPLY"] = 3] = "MULTIPLY";
    TokenType[TokenType["DIVIDE"] = 4] = "DIVIDE";
    TokenType[TokenType["POW"] = 5] = "POW";
    TokenType[TokenType["LEFT_PAREN"] = 6] = "LEFT_PAREN";
    TokenType[TokenType["RIGHT_PAREN"] = 7] = "RIGHT_PAREN";
    TokenType[TokenType["FLOAT_LITERAL"] = 8] = "FLOAT_LITERAL";
    TokenType[TokenType["INT_LITERAL"] = 9] = "INT_LITERAL";
    TokenType[TokenType["IDENTIFIER"] = 10] = "IDENTIFIER";
    TokenType[TokenType["EOF"] = 11] = "EOF";
})(TokenType || (TokenType = {}));
function startsExpression(token) {
    var type = token.type;
    return (type === TokenType.IDENTIFIER ||
        type === TokenType.INT_LITERAL ||
        type === TokenType.FLOAT_LITERAL ||
        type === TokenType.LEFT_PAREN);
}
function endsExpression(token) {
    var type = token.type;
    var isSpecialFunction = (token.type === TokenType.IDENTIFIER &&
        supportedFunctions.indexOf(token.value) !== -1);
    return (!isSpecialFunction &&
        type === TokenType.IDENTIFIER ||
        type === TokenType.INT_LITERAL ||
        type === TokenType.FLOAT_LITERAL ||
        type === TokenType.RIGHT_PAREN);
}
function insertImplicitMultiplications(tokens) {
    var result = [];
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (result.length === 0) {
            result.push(token);
            continue;
        }
        var prevToken = result[result.length - 1];
        var nextToken = token;
        if (endsExpression(prevToken) && startsExpression(nextToken)) {
            result.push({
                type: TokenType.MULTIPLY,
                value: '*'
            });
        }
        result.push(nextToken);
    }
    return result;
}
var tokenRegex = new RegExp("([0-9]+\\.[0-9]+|[0-9]+\\.|\\.[0-9]+|[0-9]+|[ \t\r\n]+|[-+*/^]|[a-zA-Z]+|[()])");
export function tokenize(input) {
    var parts = input.split(tokenRegex);
    var tokens = [];
    for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (i % 2 === 0) {
            if (part.length !== 0) {
                throw new ParserError(ErrorMsg.invalidCharacter(part[0]));
            }
            continue;
        }
        if ((part[0] >= '0' && part[0] <= '9') || part[0] === '.' && part.length !== 0) {
            if (part.indexOf('.') === 0) {
                tokens.push({
                    type: TokenType.INT_LITERAL,
                    value: part
                });
            }
            else {
                tokens.push({
                    type: TokenType.FLOAT_LITERAL,
                    value: part
                });
            }
        }
        else if (part[0] === ' ' || part[0] === '\t' || part[0] === '\r' || part[0] === '\n') {
        }
        else if ((part[0] >= 'a' && part[0] <= 'z') || (part[0] >= 'A' && part[0] <= 'Z')) {
            tokens.push({
                type: TokenType.IDENTIFIER,
                value: part
            });
        }
        else if (part[0] === '-' || part[0] === '*' || part[0] === '/' || part[0] === '+' || part[0] === '^') {
            var type = (part[0] === '-' ? TokenType.MINUS :
                part[0] === '+' ? TokenType.PLUS :
                    part[0] === '/' ? TokenType.DIVIDE :
                        part[0] === '*' ? TokenType.MULTIPLY :
                            part[0] === '^' ? TokenType.POW :
                                TokenType.NONE);
            tokens.push({
                type: type,
                value: part
            });
        }
        else if (part[0] === '(' || part[0] === ')') {
            tokens.push({
                type: part[0] === '(' ? TokenType.LEFT_PAREN : TokenType.RIGHT_PAREN,
                value: part
            });
        }
        else {
            throw new ParserError(ErrorMsg.invalidCharacter(part[0]));
        }
    }
    return insertImplicitMultiplications(tokens);
}
