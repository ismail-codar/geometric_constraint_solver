import { ParserError, ErrorMsg } from './error';
import { NodeType } from './expression-parser';
export var Precedence;
(function (Precedence) {
    Precedence[Precedence["LOWEST"] = 0] = "LOWEST";
    Precedence[Precedence["SUM"] = 1] = "SUM";
    Precedence[Precedence["PRODUCT"] = 2] = "PRODUCT";
    Precedence[Precedence["EXPONENT"] = 3] = "EXPONENT";
    Precedence[Precedence["PREFIX"] = 4] = "PREFIX";
    Precedence[Precedence["CALL"] = 5] = "CALL";
})(Precedence || (Precedence = {}));
var ExpressionParser = (function () {
    function ExpressionParser(_ctx) {
        this._ctx = _ctx;
        this._parselets = Object.create(null);
    }
    ExpressionParser.prototype.registerParseletPrefix = function (tokenType, prefixParse) {
        this.getParselet(tokenType).prefixParse = prefixParse;
    };
    ExpressionParser.prototype.registerParseletInfix = function (tokenType, infixPrecedence, infixParse) {
        this.getParselet(tokenType, infixPrecedence).infixParse = infixParse;
    };
    ExpressionParser.prototype.registerTerminal = function (tokenType, createNode) {
        this.registerParseletPrefix(tokenType, function (_, token) {
            return createNode(token);
        });
    };
    ExpressionParser.prototype.registerPrefixUnaryOperator = function (tokenType) {
        this.registerParseletPrefix(tokenType, function (parser, token) {
            var operand = parser.parseExpression(Precedence.PREFIX);
            if (!operand) {
                throw new ParserError(ErrorMsg.operatorMissingRightOperand(token.value));
            }
            return {
                type: NodeType.PREFIX_OPERATOR,
                token: token,
                argument: operand
            };
        });
    };
    ExpressionParser.prototype.registerInfixBinaryOperator = function (tokenType, precedence) {
        this.registerParseletInfix(tokenType, precedence, function (parser, left, token) {
            var right = parser.parseExpression(precedence);
            if (!right) {
                throw new ParserError(ErrorMsg.operatorMissingRightOperand(token.value));
            }
            return {
                type: NodeType.BINARY_OPERATOR,
                token: token,
                firstArgument: left,
                secondArgument: right
            };
        });
    };
    ExpressionParser.prototype.getParselet = function (tokenType, infixPrecedence) {
        if (infixPrecedence === void 0) { infixPrecedence = null; }
        if (!this._parselets[tokenType]) {
            this._parselets[tokenType] = {
                prefixParse: null,
                infixPrecedence: null,
                infixParse: null
            };
        }
        var parselet = this._parselets[tokenType];
        if (infixPrecedence !== null) {
            parselet.infixPrecedence = infixPrecedence;
        }
        return parselet;
    };
    ExpressionParser.prototype.peek = function () {
        return this._ctx.peek();
    };
    ExpressionParser.prototype.consumeIfPresent = function (tokenType) {
        if (this._ctx.peek().type === tokenType) {
            this._ctx.next();
            return true;
        }
        return false;
    };
    ExpressionParser.prototype.peekTokenPrecedence = function () {
        var token = this._ctx.peek();
        if (!token) {
            return Precedence.LOWEST;
        }
        var parselet = this._parselets[token.type];
        return (parselet && parselet.infixPrecedence != null ?
            parselet.infixPrecedence :
            Precedence.LOWEST);
    };
    ExpressionParser.prototype.parseExpression = function (precedence) {
        var token = this._ctx.peek();
        if (!token) {
            throw Error('Missing token in parseExpression');
        }
        var parselet = this._parselets[token.type];
        if (!parselet || !parselet.prefixParse) {
            return null;
        }
        this._ctx.next();
        var left = parselet.prefixParse(this, token);
        while (precedence < this.peekTokenPrecedence()) {
            token = this._ctx.next();
            var parselet_1 = this._parselets[token.type];
            if (!parselet_1 || !parselet_1.infixParse) {
                throw Error('Missing parselet or infix parselet');
            }
            left = parselet_1.infixParse(this, left, token);
        }
        return left;
    };
    return ExpressionParser;
}());
export { ExpressionParser };
