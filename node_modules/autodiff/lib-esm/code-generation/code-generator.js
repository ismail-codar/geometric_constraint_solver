import { NodeType } from '../parser/expression-parser';
import * as series from '../series/series';
import * as series2D from '../series/series2d';
import { defaultContext } from '../series/autodiff-context';
function getFunctionName(f) {
    return (f.name != null ?
        f.name :
        /function ([^(]*)/.exec(f + '')[1]);
}
export var supportedFunctions = [
    getFunctionName(series.sqrt),
    getFunctionName(series.exp),
    getFunctionName(series.log),
    getFunctionName(series.sin),
    getFunctionName(series.cos),
    getFunctionName(series.tan),
    getFunctionName(series.asin),
    getFunctionName(series.acos),
    getFunctionName(series.atan),
];
export var FunctionType;
(function (FunctionType) {
    FunctionType[FunctionType["SINGLE_VARIABLE"] = 0] = "SINGLE_VARIABLE";
    FunctionType[FunctionType["TWO_VARIABLE"] = 1] = "TWO_VARIABLE";
})(FunctionType || (FunctionType = {}));
export function generateJavascriptForExpression(ctx, node) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR: {
            var op = node.token.value;
            var functionName = (op === '+' ? 's.' + getFunctionName(series.add) :
                op === '-' ? 's.' + getFunctionName(series.subtract) :
                    op === '*' ? 's.' + getFunctionName(series.multiply) :
                        op === '/' ? 's.' + getFunctionName(series.divide) :
                            op === '^' ? 's.' + getFunctionName(series.pow) :
                                null);
            if (!functionName) {
                throw new Error("Unhandled operator in toAutodiffSource");
            }
            return functionName + "(" + generateJavascriptForExpression(ctx, node.firstArgument) + ", " + generateJavascriptForExpression(ctx, node.secondArgument) + ")";
        }
        case NodeType.FUNCTION_CALL: {
            var functionName = node["function"].token.value;
            if (supportedFunctions.indexOf(functionName) === -1) {
                throw new Error(functionName + " is not a supported function");
            }
            return "s." + functionName + "(" + generateJavascriptForExpression(ctx, node.argument) + ")";
        }
        case NodeType.IDENTIFIER: {
            var name_1 = node.token.value;
            var idx = ctx.independentVariables.indexOf(name_1);
            if (idx === -1) {
                throw new Error("That expression contains an identifier that isn't an independent variable: " + name_1);
            }
            switch (ctx.type) {
                case FunctionType.SINGLE_VARIABLE: {
                    return "s.variableEvaluatedAtPoint(" + name_1 + ")";
                }
                case FunctionType.TWO_VARIABLE: {
                    if (idx === 0) {
                        return "s.xEvaluatedAtPoint(" + name_1 + ")";
                    }
                    else if (idx === 1) {
                        return "s.yEvaluatedAtPoint(" + name_1 + ")";
                    }
                    else {
                        throw new Error("Invalid idx " + idx + " for function of type " + FunctionType[ctx.type]);
                    }
                }
            }
        }
        case NodeType.LITERAL: {
            return node.token.value;
        }
        case NodeType.PREFIX_OPERATOR: {
            if (node.token.value === '-') {
                return "s." + getFunctionName(series.negative) + "(" + generateJavascriptForExpression(ctx, node.argument) + ")";
            }
            else if (node.token.value === '+') {
            }
            else {
                throw new Error("Unhandled operator in toAutodiffSource");
            }
        }
        case NodeType.GROUP: {
            return generateJavascriptForExpression(ctx, node.argument);
        }
    }
}
var seriesAPI = {
    toValueAndDerivatives: series.toValueAndDerivatives,
    variableEvaluatedAtPoint: series.variableEvaluatedAtPoint,
    add: series.add,
    subtract: series.subtract,
    divide: series.divide,
    multiply: series.multiply,
    negative: series.negative,
    sqrt: series.sqrt,
    pow: series.pow,
    exp: series.exp,
    log: series.log,
    sin: series.sin,
    cos: series.cos,
    tan: series.tan,
    asin: series.asin,
    acos: series.acos,
    atan: series.atan
};
var series2DAPI = {
    toValueAndDerivatives: series2D.toValueAndDerivatives,
    xEvaluatedAtPoint: series2D.xEvaluatedAtPoint,
    yEvaluatedAtPoint: series2D.yEvaluatedAtPoint,
    add: series2D.add,
    subtract: series2D.subtract,
    divide: series2D.divide,
    multiply: series2D.multiply,
    negative: series2D.negative,
    sqrt: series2D.sqrt,
    pow: series2D.pow,
    exp: series2D.exp,
    log: series2D.log,
    sin: series2D.sin,
    cos: series2D.cos,
    tan: series2D.tan,
    asin: series2D.asin,
    acos: series2D.acos,
    atan: series2D.atan
};
export function buildSingleVariableAutodiffFunctionForExpression(expression, independentVariable) {
    var ctx = {
        type: FunctionType.SINGLE_VARIABLE,
        independentVariables: [independentVariable]
    };
    var src = generateJavascriptForExpression(ctx, expression);
    var wrappedFunc = new Function(independentVariable, "s", "return s." + getFunctionName(series.toValueAndDerivatives) + "(" + src + ")");
    return function (x) {
        var res = null;
        defaultContext.seriesPool.trackAndReleaseAllocations(function () {
            res = wrappedFunc(x, seriesAPI);
        });
        return res;
    };
}
export function buildTwoVariableAutodiffFunctionForExpression(expression, independentVariables) {
    var ctx = {
        type: FunctionType.TWO_VARIABLE,
        independentVariables: independentVariables
    };
    var src = generateJavascriptForExpression(ctx, expression);
    var wrappedFunc = new Function(independentVariables[0], independentVariables[1], "s", "return s." + getFunctionName(series2D.toValueAndDerivatives) + "(" + src + ")");
    return function (x, y) {
        var res = null;
        defaultContext.series2DPool.trackAndReleaseAllocations(function () {
            res = wrappedFunc(x, y, series2DAPI);
        });
        return res;
    };
}
