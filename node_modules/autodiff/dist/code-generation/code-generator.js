"use strict";
exports.__esModule = true;
var expression_parser_1 = require("../parser/expression-parser");
var series = require("../series/series");
var series2D = require("../series/series2d");
var autodiff_context_1 = require("../series/autodiff-context");
function getFunctionName(f) {
    return (f.name != null ?
        f.name :
        /function ([^(]*)/.exec(f + '')[1]);
}
exports.supportedFunctions = [
    getFunctionName(series.sqrt),
    getFunctionName(series.exp),
    getFunctionName(series.log),
    getFunctionName(series.sin),
    getFunctionName(series.cos),
    getFunctionName(series.tan),
    getFunctionName(series.asin),
    getFunctionName(series.acos),
    getFunctionName(series.atan),
];
var FunctionType;
(function (FunctionType) {
    FunctionType[FunctionType["SINGLE_VARIABLE"] = 0] = "SINGLE_VARIABLE";
    FunctionType[FunctionType["TWO_VARIABLE"] = 1] = "TWO_VARIABLE";
})(FunctionType = exports.FunctionType || (exports.FunctionType = {}));
function generateJavascriptForExpression(ctx, node) {
    switch (node.type) {
        case expression_parser_1.NodeType.BINARY_OPERATOR: {
            var op = node.token.value;
            var functionName = (op === '+' ? 's.' + getFunctionName(series.add) :
                op === '-' ? 's.' + getFunctionName(series.subtract) :
                    op === '*' ? 's.' + getFunctionName(series.multiply) :
                        op === '/' ? 's.' + getFunctionName(series.divide) :
                            op === '^' ? 's.' + getFunctionName(series.pow) :
                                null);
            if (!functionName) {
                throw new Error("Unhandled operator in toAutodiffSource");
            }
            return functionName + "(" + generateJavascriptForExpression(ctx, node.firstArgument) + ", " + generateJavascriptForExpression(ctx, node.secondArgument) + ")";
        }
        case expression_parser_1.NodeType.FUNCTION_CALL: {
            var functionName = node["function"].token.value;
            if (exports.supportedFunctions.indexOf(functionName) === -1) {
                throw new Error(functionName + " is not a supported function");
            }
            return "s." + functionName + "(" + generateJavascriptForExpression(ctx, node.argument) + ")";
        }
        case expression_parser_1.NodeType.IDENTIFIER: {
            var name_1 = node.token.value;
            var idx = ctx.independentVariables.indexOf(name_1);
            if (idx === -1) {
                throw new Error("That expression contains an identifier that isn't an independent variable: " + name_1);
            }
            switch (ctx.type) {
                case FunctionType.SINGLE_VARIABLE: {
                    return "s.variableEvaluatedAtPoint(" + name_1 + ")";
                }
                case FunctionType.TWO_VARIABLE: {
                    if (idx === 0) {
                        return "s.xEvaluatedAtPoint(" + name_1 + ")";
                    }
                    else if (idx === 1) {
                        return "s.yEvaluatedAtPoint(" + name_1 + ")";
                    }
                    else {
                        throw new Error("Invalid idx " + idx + " for function of type " + FunctionType[ctx.type]);
                    }
                }
            }
        }
        case expression_parser_1.NodeType.LITERAL: {
            return node.token.value;
        }
        case expression_parser_1.NodeType.PREFIX_OPERATOR: {
            if (node.token.value === '-') {
                return "s." + getFunctionName(series.negative) + "(" + generateJavascriptForExpression(ctx, node.argument) + ")";
            }
            else if (node.token.value === '+') {
            }
            else {
                throw new Error("Unhandled operator in toAutodiffSource");
            }
        }
        case expression_parser_1.NodeType.GROUP: {
            return generateJavascriptForExpression(ctx, node.argument);
        }
    }
}
exports.generateJavascriptForExpression = generateJavascriptForExpression;
var seriesAPI = {
    toValueAndDerivatives: series.toValueAndDerivatives,
    variableEvaluatedAtPoint: series.variableEvaluatedAtPoint,
    add: series.add,
    subtract: series.subtract,
    divide: series.divide,
    multiply: series.multiply,
    negative: series.negative,
    sqrt: series.sqrt,
    pow: series.pow,
    exp: series.exp,
    log: series.log,
    sin: series.sin,
    cos: series.cos,
    tan: series.tan,
    asin: series.asin,
    acos: series.acos,
    atan: series.atan
};
var series2DAPI = {
    toValueAndDerivatives: series2D.toValueAndDerivatives,
    xEvaluatedAtPoint: series2D.xEvaluatedAtPoint,
    yEvaluatedAtPoint: series2D.yEvaluatedAtPoint,
    add: series2D.add,
    subtract: series2D.subtract,
    divide: series2D.divide,
    multiply: series2D.multiply,
    negative: series2D.negative,
    sqrt: series2D.sqrt,
    pow: series2D.pow,
    exp: series2D.exp,
    log: series2D.log,
    sin: series2D.sin,
    cos: series2D.cos,
    tan: series2D.tan,
    asin: series2D.asin,
    acos: series2D.acos,
    atan: series2D.atan
};
function buildSingleVariableAutodiffFunctionForExpression(expression, independentVariable) {
    var ctx = {
        type: FunctionType.SINGLE_VARIABLE,
        independentVariables: [independentVariable]
    };
    var src = generateJavascriptForExpression(ctx, expression);
    var wrappedFunc = new Function(independentVariable, "s", "return s." + getFunctionName(series.toValueAndDerivatives) + "(" + src + ")");
    return function (x) {
        var res = null;
        autodiff_context_1.defaultContext.seriesPool.trackAndReleaseAllocations(function () {
            res = wrappedFunc(x, seriesAPI);
        });
        return res;
    };
}
exports.buildSingleVariableAutodiffFunctionForExpression = buildSingleVariableAutodiffFunctionForExpression;
function buildTwoVariableAutodiffFunctionForExpression(expression, independentVariables) {
    var ctx = {
        type: FunctionType.TWO_VARIABLE,
        independentVariables: independentVariables
    };
    var src = generateJavascriptForExpression(ctx, expression);
    var wrappedFunc = new Function(independentVariables[0], independentVariables[1], "s", "return s." + getFunctionName(series2D.toValueAndDerivatives) + "(" + src + ")");
    return function (x, y) {
        var res = null;
        autodiff_context_1.defaultContext.series2DPool.trackAndReleaseAllocations(function () {
            res = wrappedFunc(x, y, series2DAPI);
        });
        return res;
    };
}
exports.buildTwoVariableAutodiffFunctionForExpression = buildTwoVariableAutodiffFunctionForExpression;
