"use strict";
exports.__esModule = true;
var tokenizer_1 = require("./tokenizer");
var stream_1 = require("./stream");
var error_1 = require("./error");
var parser_context_1 = require("./parser-context");
var pratt_parser_1 = require("./pratt-parser");
var NodeType;
(function (NodeType) {
    NodeType[NodeType["FUNCTION_CALL"] = 0] = "FUNCTION_CALL";
    NodeType[NodeType["IDENTIFIER"] = 1] = "IDENTIFIER";
    NodeType[NodeType["LITERAL"] = 2] = "LITERAL";
    NodeType[NodeType["PREFIX_OPERATOR"] = 3] = "PREFIX_OPERATOR";
    NodeType[NodeType["BINARY_OPERATOR"] = 4] = "BINARY_OPERATOR";
    NodeType[NodeType["GROUP"] = 5] = "GROUP";
})(NodeType = exports.NodeType || (exports.NodeType = {}));
function children(node) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR: return [node.firstArgument, node.secondArgument];
        case NodeType.FUNCTION_CALL: return [node.argument];
        case NodeType.IDENTIFIER: return [];
        case NodeType.LITERAL: return [];
        case NodeType.PREFIX_OPERATOR: return [node.argument];
        case NodeType.GROUP: return [node.argument];
    }
}
exports.children = children;
function toDebugString(node) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR:
            return "[" + toDebugString(node.firstArgument) + " " + node.token.value + " " + toDebugString(node.secondArgument) + "]";
        case NodeType.FUNCTION_CALL: return "[" + toDebugString(node["function"]) + "(" + toDebugString(node.argument) + ")]";
        case NodeType.IDENTIFIER: return "[" + node.token.value + "]";
        case NodeType.LITERAL: return "[" + node.token.value + "]";
        case NodeType.PREFIX_OPERATOR: return "[" + node.token.value + " " + toDebugString(node.argument) + "]";
        case NodeType.GROUP: return "[( " + toDebugString(node.argument) + " )]";
    }
}
exports.toDebugString = toDebugString;
function forEachNode(node, callback) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR: {
            forEachNode(node.firstArgument, callback);
            forEachNode(node.secondArgument, callback);
            break;
        }
        case NodeType.IDENTIFIER:
        case NodeType.LITERAL: {
            break;
        }
        case NodeType.FUNCTION_CALL:
        case NodeType.PREFIX_OPERATOR:
        case NodeType.GROUP: {
            forEachNode(node.argument, callback);
            break;
        }
    }
    callback(node);
}
exports.forEachNode = forEachNode;
function parseExpression(source) {
    source = source.trim();
    if (source.length === 0) {
        return {
            expression: null,
            userReadableError: ''
        };
    }
    var tokens = null;
    try {
        tokens = new stream_1.Stream(tokenizer_1.tokenize(source));
    }
    catch (err) {
        if (error_1.isParserError(err)) {
            return {
                expression: null,
                userReadableError: err.message
            };
        }
    }
    var ctx = new parser_context_1.ParserContext(tokens);
    var parser = new pratt_parser_1.ExpressionParser(ctx);
    parser.registerTerminal(tokenizer_1.TokenType.INT_LITERAL, function (token) {
        return {
            type: NodeType.LITERAL,
            token: token
        };
    });
    parser.registerTerminal(tokenizer_1.TokenType.FLOAT_LITERAL, function (token) {
        return {
            type: NodeType.LITERAL,
            token: token
        };
    });
    parser.registerTerminal(tokenizer_1.TokenType.IDENTIFIER, function (token) {
        return {
            type: NodeType.IDENTIFIER,
            token: token
        };
    });
    parser.registerPrefixUnaryOperator(tokenizer_1.TokenType.PLUS);
    parser.registerPrefixUnaryOperator(tokenizer_1.TokenType.MINUS);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.PLUS, pratt_parser_1.Precedence.SUM);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.MINUS, pratt_parser_1.Precedence.SUM);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.MULTIPLY, pratt_parser_1.Precedence.PRODUCT);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.DIVIDE, pratt_parser_1.Precedence.PRODUCT);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.POW, pratt_parser_1.Precedence.EXPONENT);
    parser.registerParseletPrefix(tokenizer_1.TokenType.LEFT_PAREN, function (parser, _) {
        var peek = parser.peek();
        if (peek && peek.value === ')') {
            throw new error_1.ParserError(error_1.ErrorMsg.emptyParens);
        }
        var expr = parser.parseExpression(pratt_parser_1.Precedence.LOWEST);
        if (!expr) {
            throw new error_1.ParserError(error_1.ErrorMsg.genericFailure);
        }
        if (!parser.consumeIfPresent(tokenizer_1.TokenType.RIGHT_PAREN)) {
            throw new error_1.ParserError(error_1.ErrorMsg.missingRightParen);
        }
        return {
            type: NodeType.GROUP,
            token: null,
            argument: expr
        };
    });
    parser.registerParseletInfix(tokenizer_1.TokenType.LEFT_PAREN, pratt_parser_1.Precedence.CALL, function (parser, left, _) {
        var children = [];
        children.push(left);
        var expr = parser.parseExpression(pratt_parser_1.Precedence.LOWEST);
        if (!expr) {
            throw new error_1.ParserError(error_1.ErrorMsg.invalidArgument(left.token.value));
        }
        if (!parser.consumeIfPresent(tokenizer_1.TokenType.RIGHT_PAREN)) {
            throw new error_1.ParserError(error_1.ErrorMsg.missingRightParen);
        }
        if (left.type !== NodeType.IDENTIFIER) {
            throw new error_1.ParserError(error_1.ErrorMsg.nonIdentifierFunctionName);
        }
        return {
            type: NodeType.FUNCTION_CALL,
            token: null,
            "function": left,
            argument: expr
        };
    });
    var expression = null;
    var userReadableError = null;
    try {
        expression = parser.parseExpression(pratt_parser_1.Precedence.LOWEST);
    }
    catch (err) {
        if (error_1.isParserError(err)) {
            userReadableError = err.message;
        }
        else {
            userReadableError = error_1.ErrorMsg.genericFailure;
        }
    }
    if (!userReadableError && ctx.hasMoreTokens()) {
        userReadableError = error_1.ErrorMsg.genericFailure;
    }
    if (userReadableError != null) {
        return { expression: null, userReadableError: userReadableError };
    }
    return {
        expression: expression,
        userReadableError: userReadableError
    };
}
exports.parseExpression = parseExpression;
