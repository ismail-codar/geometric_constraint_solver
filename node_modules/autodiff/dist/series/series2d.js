"use strict";
exports.__esModule = true;
var factorial_1 = require("./factorial");
var autodiff_context_1 = require("./autodiff-context");
function xEvaluatedAtPoint(value) {
    var series = autodiff_context_1.defaultContext.series2DPool.allocate();
    series.set(0, 0, value);
    series.set(1, 0, 1);
    return series;
}
exports.xEvaluatedAtPoint = xEvaluatedAtPoint;
function yEvaluatedAtPoint(value) {
    var series = autodiff_context_1.defaultContext.series2DPool.allocate();
    series.set(0, 0, value);
    series.set(0, 1, 1);
    return series;
}
exports.yEvaluatedAtPoint = yEvaluatedAtPoint;
function constantValue(value) {
    var series = autodiff_context_1.defaultContext.series2DPool.allocate();
    series.set(0, 0, value);
    return series;
}
exports.constantValue = constantValue;
var Series2D = (function () {
    function Series2D() {
        this.isFree = false;
        this.coefficients = [];
        this.size = -1;
        var globalDegree = autodiff_context_1.defaultContext.numDerivativesToCompute();
        this.size = globalDegree + 1;
        for (var y = 0; y <= globalDegree; y++) {
            for (var x = 0; x <= globalDegree; x++) {
                this.coefficients.push(0);
            }
        }
    }
    Series2D.prototype.set = function (x, y, value) {
        this.coefficients[y * this.size + x] = value;
    };
    Series2D.prototype.get = function (x, y) {
        return this.coefficients[y * this.size + x];
    };
    Series2D.prototype.debugPrint = function () {
        var s = '';
        for (var y = 0; y < this.size; y++) {
            for (var x = 0; x < this.size; x++) {
                s += this.coefficients[y * this.size + x] + " ";
            }
            s += "\n";
        }
        console.log(s);
    };
    Series2D.prototype.freeToPool = function () {
        autodiff_context_1.defaultContext.series2DPool.markFree(this);
    };
    return Series2D;
}());
exports.Series2D = Series2D;
function toValueAndDerivatives(s) {
    var derivatives = [];
    for (var y = 0; y < s.size; y++) {
        for (var x = 0; x < s.size; x++) {
            derivatives.push(s.get(x, y) * (factorial_1.factorial(x) * factorial_1.factorial(y)));
        }
    }
    return derivatives;
}
exports.toValueAndDerivatives = toValueAndDerivatives;
function add(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a + b);
    }
    else if (typeof a === 'number' && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocateCopy(b);
        res.coefficients[0] += a;
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocateCopy(a);
        res.coefficients[0] += b;
        return res;
    }
    else if (a instanceof Series2D && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocateCopy(a);
        for (var i = 0; i < a.coefficients.length; i++) {
            res.coefficients[i] += b.coefficients[i];
        }
        return res;
    }
    throw new Error('Unhandled case in add');
}
exports.add = add;
function negative(a) {
    if (typeof a === 'number') {
        return constantValue(-a);
    }
    else if (a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocateCopy(a);
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] *= -1;
        }
        return res;
    }
    throw new Error('Unhandled case in negative');
}
exports.negative = negative;
function subtract(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a - b);
    }
    else if (typeof a === 'number' && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a - b.coefficients[i];
        }
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] - b;
        }
        return res;
    }
    else if (a instanceof Series2D && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] - b.coefficients[i];
        }
        return res;
    }
    throw new Error('Unhandled case in subtract');
}
exports.subtract = subtract;
function convolve(a, b, boxWidth, boxHeight) {
    var total = 0;
    for (var x = 0; x < boxWidth; x++) {
        for (var y = 0; y < boxHeight; y++) {
            total += a.get(x, y) * b.get(boxWidth - 1 - x, boxHeight - 1 - y);
        }
    }
    return total;
}
exports.convolve = convolve;
var Coordinate;
(function (Coordinate) {
    Coordinate[Coordinate["X"] = 0] = "X";
    Coordinate[Coordinate["Y"] = 1] = "Y";
})(Coordinate || (Coordinate = {}));
function dConvolve(a, b, k_x, k_y) {
    if (k_x === 0 && k_y === 0) {
        throw new Error("dConvolve called with k_x === 0 and k_y === 0");
    }
    var k = [k_x, k_y];
    var p = (k_x === 0 ? Coordinate.Y :
        k_y === 0 ? Coordinate.X :
            k_x <= k_y ? Coordinate.X :
                Coordinate.Y);
    var k_p = k[p];
    var e_p = p === Coordinate.X ? [1, 0] : [0, 1];
    var total = 0;
    for (var x = e_p[0]; x <= k_x; x++) {
        for (var y = e_p[1]; y <= k_y; y++) {
            if (x === k_x && y === k_y) {
                continue;
            }
            var j = [x, y];
            var j_p = j[p];
            total += j_p * a.get(x, y) * b.get(k_x - x, k_y - y);
        }
    }
    var res = total / k_p;
    return res;
}
exports.dConvolve = dConvolve;
function multiply(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a * b);
    }
    else if (typeof a === 'number' && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a * b.coefficients[i];
        }
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] * b;
        }
        return res;
    }
    else if (a instanceof Series2D && b instanceof Series2D) {
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var size = a.size;
        for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++) {
                var h_ij = convolve(a, b, i + 1, j + 1);
                h.set(i, j, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in multiply');
}
exports.multiply = multiply;
function divide(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a / b);
    }
    else if (typeof a === 'number' && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a / b.coefficients[i];
        }
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] / b;
        }
        return res;
    }
    else if (a instanceof Series2D && b instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++) {
                if (i === 0 && j === 0) {
                    h.set(i, j, a.get(0, 0) / b.get(0, 0));
                    continue;
                }
                var a_ij = a.get(i, j);
                var b_00 = b.get(0, 0);
                var sum = convolve(h, b, i + 1, j + 1) - h.get(i, j) * b_00;
                var h_ij = (a_ij - sum) / b_00;
                h.set(i, j, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in divide');
}
exports.divide = divide;
function exp(a) {
    if (typeof a === 'number') {
        return constantValue(Math.exp(a));
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(x, y, Math.exp(a.get(0, 0)));
                    continue;
                }
                var h_ij = h.get(0, 0) * a.get(x, y) + dConvolve(a, h, x, y);
                h.set(x, y, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in exp');
}
exports.exp = exp;
function log(a) {
    if (typeof a === 'number') {
        if (a < 0) {
            throw new Error("log called with a negative number");
        }
        return constantValue(Math.log(a));
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(x, y, Math.log(a.get(0, 0)));
                    continue;
                }
                var h_ij = (a.get(x, y) - dConvolve(h, a, x, y)) / a.get(0, 0);
                h.set(x, y, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in log');
}
exports.log = log;
function sqrt(a) {
    if (typeof a === 'number') {
        return constantValue(Math.sqrt(a));
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(x, y, Math.sqrt(a.get(0, 0)));
                    continue;
                }
                var h_ij = (a.get(x, y) - 2 * dConvolve(h, h, x, y)) / (2 * h.get(0, 0));
                h.set(x, y, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in sqrt');
}
exports.sqrt = sqrt;
function isNegative(a) {
    if (typeof a === 'number') {
        return a < 0;
    }
    else if (a instanceof Series2D) {
        return a.get(0, 0) < 0;
    }
    throw new Error('Unhandled case in isNegative');
}
function pow(a, b) {
    if (isNegative(a)) {
        var series = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < series.coefficients.length; i++) {
            series.coefficients[i] = NaN;
        }
        return series;
    }
    return exp(multiply(b, log(a)));
}
exports.pow = pow;
function sinAndCos(a) {
    if (typeof a === 'number') {
        return [
            constantValue(Math.sin(a)),
            constantValue(Math.cos(a)),
        ];
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var sinResult = autodiff_context_1.defaultContext.series2DPool.allocate();
        var cosResult = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    sinResult.set(x, y, Math.sin(a.get(0, 0)));
                    cosResult.set(x, y, Math.cos(a.get(0, 0)));
                    continue;
                }
                var s_ij = cosResult.get(0, 0) * a.get(x, y) + dConvolve(a, cosResult, x, y);
                sinResult.set(x, y, s_ij);
                var c_ij = -sinResult.get(0, 0) * a.get(x, y) - dConvolve(a, sinResult, x, y);
                cosResult.set(x, y, c_ij);
            }
        }
        return [
            sinResult,
            cosResult,
        ];
    }
    throw new Error('Unhandled case in sinAndCos');
}
function sin(a) {
    var res = sinAndCos(a);
    res[1].freeToPool();
    return res[0];
}
exports.sin = sin;
function cos(a) {
    var res = sinAndCos(a);
    res[0].freeToPool();
    return res[1];
}
exports.cos = cos;
function tan(a) {
    if (typeof a === 'number') {
        return constantValue(Math.tan(a));
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var b = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    var a_00 = a.get(0, 0);
                    h.set(x, y, Math.tan(a_00));
                    b.set(x, y, 1 / (Math.cos(a_00) * Math.cos(a_00)));
                    continue;
                }
                var h_xy = b.get(0, 0) * a.get(x, y) + dConvolve(a, b, x, y);
                h.set(x, y, h_xy);
                var b_xy = 2 * (h.get(0, 0) * h.get(x, y) + dConvolve(h, h, x, y));
                b.set(x, y, b_xy);
            }
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in tan');
}
exports.tan = tan;
function asin(a) {
    if (typeof a === 'number') {
        if (Math.abs(a) >= 1) {
            console.warn("asin called with value " + a);
        }
        return constantValue(Math.asin(a));
    }
    else if (a instanceof Series2D) {
        if (Math.abs(a.coefficients[0]) >= 1) {
            console.warn("asin called with value " + a.coefficients[0]);
        }
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var b = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(0, 0, Math.asin(a.get(0, 0)));
                    b.set(0, 0, Math.cos(h.get(0, 0)));
                    continue;
                }
                var h_ij = (a.get(x, y) - dConvolve(h, b, x, y)) / b.get(0, 0);
                h.set(x, y, h_ij);
                var b_ij = -a.get(0, 0) * h.get(x, y) - dConvolve(h, a, x, y);
                b.set(x, y, b_ij);
            }
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in asin');
}
exports.asin = asin;
function acos(a) {
    if (typeof a === 'number') {
        if (Math.abs(a) >= 1) {
            console.warn("asin called with value " + a);
        }
        return constantValue(Math.acos(a));
    }
    else if (a instanceof Series2D) {
        if (Math.abs(a.coefficients[0]) >= 1) {
            console.warn("asin called with value " + a.coefficients[0]);
        }
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var b = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(0, 0, Math.acos(a.get(0, 0)));
                    b.set(0, 0, Math.sin(h.get(0, 0)));
                    continue;
                }
                var h_ij = (a.get(x, y) + dConvolve(h, b, x, y)) / -b.get(0, 0);
                h.set(x, y, h_ij);
                var b_ij = a.get(0, 0) * h.get(x, y) + dConvolve(h, a, x, y);
                b.set(x, y, b_ij);
            }
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in asin');
}
exports.acos = acos;
function atan(a) {
    if (typeof a === 'number') {
        return constantValue(Math.atan(a));
    }
    else if (a instanceof Series2D) {
        if (Math.abs(a.coefficients[0]) >= 1) {
            console.warn("asin called with value " + a.coefficients[0]);
        }
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var b = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    var a_00 = a.get(0, 0);
                    h.set(x, y, Math.atan(a_00));
                    b.set(x, y, 1 + a_00 * a_00);
                    continue;
                }
                var h_ij = (a.get(x, y) - dConvolve(h, b, x, y)) / b.get(0, 0);
                h.set(x, y, h_ij);
                var b_ij = 2 * (a.get(0, 0) * a.get(x, y) + dConvolve(a, a, x, y));
                b.set(x, y, b_ij);
            }
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in atan');
}
exports.atan = atan;
