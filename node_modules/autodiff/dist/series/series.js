"use strict";
exports.__esModule = true;
var factorial_1 = require("./factorial");
var autodiff_context_1 = require("./autodiff-context");
function variableEvaluatedAtPoint(value) {
    var series = autodiff_context_1.defaultContext.seriesPool.allocate();
    series.coefficients[0] = value;
    series.coefficients[1] = 1;
    return series;
}
exports.variableEvaluatedAtPoint = variableEvaluatedAtPoint;
function constantValue(value) {
    var series = autodiff_context_1.defaultContext.seriesPool.allocate();
    series.coefficients[0] = value;
    return series;
}
exports.constantValue = constantValue;
var Series = (function () {
    function Series() {
        this.isFree = false;
        this.coefficients = [];
        var numTerms = 1 + autodiff_context_1.defaultContext.numDerivativesToCompute();
        while (this.coefficients.length < numTerms) {
            this.coefficients.push(0);
        }
    }
    Series.prototype.freeToPool = function () {
        autodiff_context_1.defaultContext.seriesPool.markFree(this);
    };
    return Series;
}());
exports.Series = Series;
function toValueAndDerivatives(s) {
    var derivatives = [];
    for (var i = 0; i < s.coefficients.length; i++) {
        derivatives.push(s.coefficients[i] * factorial_1.factorial(i));
    }
    return derivatives;
}
exports.toValueAndDerivatives = toValueAndDerivatives;
function add(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a + b);
    }
    else if (typeof a === 'number' && b instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocateCopy(b);
        res.coefficients[0] += a;
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocateCopy(a);
        res.coefficients[0] += b;
        return res;
    }
    else if (a instanceof Series && b instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocateCopy(a);
        for (var i = 0; i < a.coefficients.length; i++) {
            res.coefficients[i] += b.coefficients[i];
        }
        return res;
    }
    throw new Error('Unhandled case in add');
}
exports.add = add;
function negative(a) {
    if (typeof a === 'number') {
        return constantValue(-a);
    }
    else if (a instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocateCopy(a);
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] *= -1;
        }
        return res;
    }
    throw new Error('Unhandled case in negative');
}
exports.negative = negative;
function subtract(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a - b);
    }
    else if (typeof a === 'number' && b instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a - b.coefficients[i];
        }
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] - b;
        }
        return res;
    }
    else if (a instanceof Series && b instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] - b.coefficients[i];
        }
        return res;
    }
    throw new Error('Unhandled case in subtract');
}
exports.subtract = subtract;
function multiply(aInput, bInput) {
    if (typeof aInput === 'number' && typeof bInput === 'number') {
        return constantValue(aInput * bInput);
    }
    else if (typeof aInput === 'number' && bInput instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = aInput * bInput.coefficients[i];
        }
        return res;
    }
    else if (typeof bInput === 'number' && aInput instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = aInput.coefficients[i] * bInput;
        }
        return res;
    }
    else if (aInput instanceof Series && bInput instanceof Series) {
        var a = aInput.coefficients;
        var b = bInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var k = 0; k < a.length; k++) {
            var convolution = 0;
            for (var i = 0; i < k + 1; i++) {
                convolution += a[i] * b[k - i];
            }
            h.coefficients[k] = convolution;
        }
        return h;
    }
    throw new Error('Unhandled case in multiply');
}
exports.multiply = multiply;
function divide(aInput, bInput) {
    if (typeof aInput === 'number' && typeof bInput === 'number') {
        return constantValue(aInput / bInput);
    }
    else if (typeof aInput === 'number' && bInput instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = aInput / bInput.coefficients[i];
        }
        return res;
    }
    else if (typeof bInput === 'number' && aInput instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = aInput.coefficients[i] / bInput;
        }
        return res;
    }
    else if (aInput instanceof Series && bInput instanceof Series) {
        var a = aInput.coefficients;
        var b = bInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = a[0] / b[0];
        for (var k = 1; k < a.length; k++) {
            var convolution = 0;
            for (var i = 0; i < k; i++) {
                convolution += h.coefficients[i] * b[k - i];
            }
            h.coefficients[k] = (a[k] - convolution) / b[0];
        }
        return h;
    }
    throw new Error('Unhandled case in divide');
}
exports.divide = divide;
function sqrt(aInput) {
    if (typeof aInput === 'number') {
        return constantValue(Math.sqrt(aInput));
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.sqrt(a[0]);
        for (var k = 1; k < a.length; k++) {
            var ak = a[k];
            var convolution = 0;
            for (var i = 1; i < k; i++) {
                convolution += h.coefficients[i] * h.coefficients[k - i];
            }
            h.coefficients[k] = (ak - convolution) / (2 * h.coefficients[0]);
        }
        return h;
    }
    throw new Error('Unhandled case in sqrt');
}
exports.sqrt = sqrt;
function exp(aInput) {
    if (typeof aInput === 'number') {
        return constantValue(Math.exp(aInput));
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.exp(a[0]);
        for (var k = 1; k < a.length; k++) {
            var convolution = 0;
            for (var i = 1; i < k + 1; i++) {
                convolution += i * a[i] * h.coefficients[k - i];
            }
            h.coefficients[k] = convolution / k;
        }
        return h;
    }
    throw new Error('Unhandled case in exp');
}
exports.exp = exp;
function log(aInput) {
    if (typeof aInput === 'number') {
        if (aInput < 0) {
            throw new Error("log called with a negative number");
        }
        return constantValue(Math.log(aInput));
    }
    else if (aInput instanceof Series) {
        if (aInput.coefficients[0] < 0) {
            throw new Error("log called with a series whose first coefficient is negative");
        }
        var a = aInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.log(a[0]);
        for (var k = 1; k < a.length; k++) {
            var convolution = 0;
            for (var i = 1; i < k; i++) {
                convolution += i * h.coefficients[i] * a[k - i];
            }
            h.coefficients[k] = (1 / a[0]) * (a[k] - convolution / k);
        }
        return h;
    }
    throw new Error('Unhandled case in log');
}
exports.log = log;
function isNegative(a) {
    if (typeof a === 'number') {
        return a < 0;
    }
    else if (a instanceof Series) {
        return a.coefficients[0] < 0;
    }
    throw new Error('Unhandled case in isNegative');
}
function pow(a, b) {
    if (isNegative(a)) {
        var series = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < series.coefficients.length; i++) {
            series.coefficients[i] = NaN;
        }
        return series;
    }
    return exp(multiply(b, log(a)));
}
exports.pow = pow;
function sinAndCos(aInput) {
    if (typeof aInput === 'number') {
        return [
            constantValue(Math.sin(aInput)),
            constantValue(Math.cos(aInput)),
        ];
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var sinResult = autodiff_context_1.defaultContext.seriesPool.allocate();
        sinResult.coefficients[0] = Math.sin(a[0]);
        var cosResult = autodiff_context_1.defaultContext.seriesPool.allocate();
        cosResult.coefficients[0] = Math.cos(a[0]);
        for (var k = 1; k < a.length; k++) {
            var sinConvolution = 0;
            var cosConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                sinConvolution += i * a[i] * cosResult.coefficients[k - i];
                cosConvolution += i * a[i] * sinResult.coefficients[k - i];
            }
            sinResult.coefficients[k] = sinConvolution / k;
            cosResult.coefficients[k] = -cosConvolution / k;
        }
        return [
            sinResult,
            cosResult,
        ];
    }
    throw new Error('Unhandled case in sinAndCos');
}
function sin(a) {
    var res = sinAndCos(a);
    res[1].freeToPool();
    return res[0];
}
exports.sin = sin;
function cos(a) {
    var res = sinAndCos(a);
    res[0].freeToPool();
    return res[1];
}
exports.cos = cos;
function tan(aInput) {
    if (typeof aInput === 'number') {
        return constantValue(Math.tan(aInput));
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var b = autodiff_context_1.defaultContext.seriesPool.allocate();
        b.coefficients[0] = 1 / (Math.cos(a[0]) * Math.cos(a[0]));
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.tan(a[0]);
        for (var k = 1; k < a.length; k++) {
            var hConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                hConvolution += i * a[i] * b.coefficients[k - i];
            }
            h.coefficients[k] = hConvolution / k;
            var bConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                bConvolution += i * h.coefficients[i] * h.coefficients[k - i];
            }
            b.coefficients[k] = 2 * bConvolution / k;
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in tan');
}
exports.tan = tan;
function asin(aInput) {
    if (typeof aInput === 'number') {
        if (Math.abs(aInput) >= 1) {
            console.warn("asin called with value " + aInput);
        }
        return constantValue(Math.asin(aInput));
    }
    else if (aInput instanceof Series) {
        if (Math.abs(aInput.coefficients[0]) >= 1) {
            console.warn("asin called with value " + aInput.coefficients[0]);
        }
        var a = aInput.coefficients;
        var b = autodiff_context_1.defaultContext.seriesPool.allocate();
        b.coefficients[0] = Math.sqrt(1 - a[0] * a[0]);
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.asin(a[0]);
        for (var k = 1; k < a.length; k++) {
            var hConvolution = 0;
            for (var i = 1; i < k; i++) {
                hConvolution += i * h.coefficients[i] * b.coefficients[k - i];
            }
            h.coefficients[k] = (a[k] - hConvolution / k) / b.coefficients[0];
            var bConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                bConvolution += i * h.coefficients[i] * a[k - i];
            }
            b.coefficients[k] = -bConvolution / k;
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in asin');
}
exports.asin = asin;
function acos(aInput) {
    if (typeof aInput === 'number') {
        if (Math.abs(aInput) >= 1) {
            console.warn("asin called with value " + aInput);
        }
        return constantValue(Math.acos(aInput));
    }
    else if (aInput instanceof Series) {
        if (Math.abs(aInput.coefficients[0]) >= 1) {
            console.warn("asin called with value " + aInput.coefficients[0]);
        }
        var a = aInput.coefficients;
        var b = autodiff_context_1.defaultContext.seriesPool.allocate();
        b.coefficients[0] = Math.sqrt(1 - a[0] * a[0]);
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.acos(a[0]);
        for (var k = 1; k < a.length; k++) {
            var hConvolution = 0;
            for (var i = 1; i < k; i++) {
                hConvolution += i * h.coefficients[i] * b.coefficients[k - i];
            }
            h.coefficients[k] = ((a[k] + hConvolution / k) / -b.coefficients[0]);
            var bConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                bConvolution += i * h.coefficients[i] * a[k - i];
            }
            b.coefficients[k] = bConvolution / k;
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in asin');
}
exports.acos = acos;
function atan(aInput) {
    if (typeof aInput === 'number') {
        return constantValue(Math.atan(aInput));
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var b = autodiff_context_1.defaultContext.seriesPool.allocate();
        b.coefficients[0] = 1 + a[0] * a[0];
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.atan(a[0]);
        for (var k = 1; k < a.length; k++) {
            var hConvolution = 0;
            for (var i = 1; i < k; i++) {
                hConvolution += i * h.coefficients[i] * b.coefficients[k - i];
            }
            h.coefficients[k] = (a[k] - hConvolution / k) / b.coefficients[0];
            var bConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                bConvolution += i * a[i] * a[k - i];
            }
            b.coefficients[k] = 2 * bConvolution / k;
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in atan');
}
exports.atan = atan;
