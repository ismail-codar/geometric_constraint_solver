(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("autodiff", [], factory);
	else if(typeof exports === 'object')
		exports["autodiff"] = factory();
	else
		root["autodiff"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 13);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var pool_1 = __webpack_require__(9);
var series_1 = __webpack_require__(2);
var series2d_1 = __webpack_require__(4);
function newSeries() {
    return new series_1.Series();
}
function clearSeries(s) {
    for (var i = 0; i < s.coefficients.length; i++) {
        s.coefficients[i] = 0;
    }
}
function copySeries(to, from) {
    for (var i = 0; i < to.coefficients.length; i++) {
        to.coefficients[i] = from.coefficients[i];
    }
}
function newSeries2D() {
    return new series2d_1.Series2D();
}
function clearSeries2D(s) {
    for (var i = 0; i < s.coefficients.length; i++) {
        s.coefficients[i] = 0;
    }
}
function copySeries2D(to, from) {
    for (var i = 0; i < to.coefficients.length; i++) {
        to.coefficients[i] = from.coefficients[i];
    }
}
var AutodiffContext = (function () {
    function AutodiffContext(opts) {
        this._numDerivativesToCompute = 3;
        this.seriesPool = new pool_1.Pool(newSeries, clearSeries, copySeries);
        this.series2DPool = new pool_1.Pool(newSeries2D, clearSeries2D, copySeries2D);
        this._numDerivativesToCompute = opts.numDerivativesToCompute;
    }
    AutodiffContext.prototype.setNumberOfDerivativesToCompute = function (n) {
        if (n !== this._numDerivativesToCompute) {
            this.seriesPool.forgetFreeElements();
            this.series2DPool.forgetFreeElements();
        }
        this._numDerivativesToCompute = n;
    };
    AutodiffContext.prototype.numDerivativesToCompute = function () {
        return this._numDerivativesToCompute;
    };
    return AutodiffContext;
}());
exports.AutodiffContext = AutodiffContext;
exports.defaultContext = new AutodiffContext({
    numDerivativesToCompute: 5
});


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.ERROR_NAME_PARSER = 'ParserError';
var ParserError = (function (_super) {
    __extends(ParserError, _super);
    function ParserError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = exports.ERROR_NAME_PARSER;
        return _this;
    }
    return ParserError;
}(Error));
exports.ParserError = ParserError;
function isParserError(err) {
    return err.name === exports.ERROR_NAME_PARSER;
}
exports.isParserError = isParserError;
var ErrorMsg;
(function (ErrorMsg) {
    ErrorMsg.genericFailure = "Couldn't parse that expression";
    ErrorMsg.emptyParens = "The expression contains an empty set of parentheses like (); this is not valid syntax";
    ErrorMsg.missingRightParen = "The expression is missing a right parenthesis";
    ErrorMsg.nonIdentifierFunctionName = "It looks like you're trying to call something that isn't a function";
    ErrorMsg.invalidArgument = function (functionName) {
        return "Couldn't parse an argument to the function " + functionName + ". Perhaps you're missing a closing parenthesis.";
    };
    ErrorMsg.operatorMissingRightOperand = function (operator) {
        return "We expected something after the operator " + operator;
    };
    ErrorMsg.invalidCharacter = function (s) {
        return s + " isn't a valid character";
    };
})(ErrorMsg = exports.ErrorMsg || (exports.ErrorMsg = {}));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var factorial_1 = __webpack_require__(6);
var autodiff_context_1 = __webpack_require__(0);
function variableEvaluatedAtPoint(value) {
    var series = autodiff_context_1.defaultContext.seriesPool.allocate();
    series.coefficients[0] = value;
    series.coefficients[1] = 1;
    return series;
}
exports.variableEvaluatedAtPoint = variableEvaluatedAtPoint;
function constantValue(value) {
    var series = autodiff_context_1.defaultContext.seriesPool.allocate();
    series.coefficients[0] = value;
    return series;
}
exports.constantValue = constantValue;
var Series = (function () {
    function Series() {
        this.isFree = false;
        this.coefficients = [];
        var numTerms = 1 + autodiff_context_1.defaultContext.numDerivativesToCompute();
        while (this.coefficients.length < numTerms) {
            this.coefficients.push(0);
        }
    }
    Series.prototype.freeToPool = function () {
        autodiff_context_1.defaultContext.seriesPool.markFree(this);
    };
    return Series;
}());
exports.Series = Series;
function toValueAndDerivatives(s) {
    var derivatives = [];
    for (var i = 0; i < s.coefficients.length; i++) {
        derivatives.push(s.coefficients[i] * factorial_1.factorial(i));
    }
    return derivatives;
}
exports.toValueAndDerivatives = toValueAndDerivatives;
function add(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a + b);
    }
    else if (typeof a === 'number' && b instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocateCopy(b);
        res.coefficients[0] += a;
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocateCopy(a);
        res.coefficients[0] += b;
        return res;
    }
    else if (a instanceof Series && b instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocateCopy(a);
        for (var i = 0; i < a.coefficients.length; i++) {
            res.coefficients[i] += b.coefficients[i];
        }
        return res;
    }
    throw new Error('Unhandled case in add');
}
exports.add = add;
function negative(a) {
    if (typeof a === 'number') {
        return constantValue(-a);
    }
    else if (a instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocateCopy(a);
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] *= -1;
        }
        return res;
    }
    throw new Error('Unhandled case in negative');
}
exports.negative = negative;
function subtract(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a - b);
    }
    else if (typeof a === 'number' && b instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a - b.coefficients[i];
        }
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] - b;
        }
        return res;
    }
    else if (a instanceof Series && b instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] - b.coefficients[i];
        }
        return res;
    }
    throw new Error('Unhandled case in subtract');
}
exports.subtract = subtract;
function multiply(aInput, bInput) {
    if (typeof aInput === 'number' && typeof bInput === 'number') {
        return constantValue(aInput * bInput);
    }
    else if (typeof aInput === 'number' && bInput instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = aInput * bInput.coefficients[i];
        }
        return res;
    }
    else if (typeof bInput === 'number' && aInput instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = aInput.coefficients[i] * bInput;
        }
        return res;
    }
    else if (aInput instanceof Series && bInput instanceof Series) {
        var a = aInput.coefficients;
        var b = bInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var k = 0; k < a.length; k++) {
            var convolution = 0;
            for (var i = 0; i < k + 1; i++) {
                convolution += a[i] * b[k - i];
            }
            h.coefficients[k] = convolution;
        }
        return h;
    }
    throw new Error('Unhandled case in multiply');
}
exports.multiply = multiply;
function divide(aInput, bInput) {
    if (typeof aInput === 'number' && typeof bInput === 'number') {
        return constantValue(aInput / bInput);
    }
    else if (typeof aInput === 'number' && bInput instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = aInput / bInput.coefficients[i];
        }
        return res;
    }
    else if (typeof bInput === 'number' && aInput instanceof Series) {
        var res = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = aInput.coefficients[i] / bInput;
        }
        return res;
    }
    else if (aInput instanceof Series && bInput instanceof Series) {
        var a = aInput.coefficients;
        var b = bInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = a[0] / b[0];
        for (var k = 1; k < a.length; k++) {
            var convolution = 0;
            for (var i = 0; i < k; i++) {
                convolution += h.coefficients[i] * b[k - i];
            }
            h.coefficients[k] = (a[k] - convolution) / b[0];
        }
        return h;
    }
    throw new Error('Unhandled case in divide');
}
exports.divide = divide;
function sqrt(aInput) {
    if (typeof aInput === 'number') {
        return constantValue(Math.sqrt(aInput));
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.sqrt(a[0]);
        for (var k = 1; k < a.length; k++) {
            var ak = a[k];
            var convolution = 0;
            for (var i = 1; i < k; i++) {
                convolution += h.coefficients[i] * h.coefficients[k - i];
            }
            h.coefficients[k] = (ak - convolution) / (2 * h.coefficients[0]);
        }
        return h;
    }
    throw new Error('Unhandled case in sqrt');
}
exports.sqrt = sqrt;
function exp(aInput) {
    if (typeof aInput === 'number') {
        return constantValue(Math.exp(aInput));
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.exp(a[0]);
        for (var k = 1; k < a.length; k++) {
            var convolution = 0;
            for (var i = 1; i < k + 1; i++) {
                convolution += i * a[i] * h.coefficients[k - i];
            }
            h.coefficients[k] = convolution / k;
        }
        return h;
    }
    throw new Error('Unhandled case in exp');
}
exports.exp = exp;
function log(aInput) {
    if (typeof aInput === 'number') {
        if (aInput < 0) {
            throw new Error("log called with a negative number");
        }
        return constantValue(Math.log(aInput));
    }
    else if (aInput instanceof Series) {
        if (aInput.coefficients[0] < 0) {
            throw new Error("log called with a series whose first coefficient is negative");
        }
        var a = aInput.coefficients;
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.log(a[0]);
        for (var k = 1; k < a.length; k++) {
            var convolution = 0;
            for (var i = 1; i < k; i++) {
                convolution += i * h.coefficients[i] * a[k - i];
            }
            h.coefficients[k] = (1 / a[0]) * (a[k] - convolution / k);
        }
        return h;
    }
    throw new Error('Unhandled case in log');
}
exports.log = log;
function isNegative(a) {
    if (typeof a === 'number') {
        return a < 0;
    }
    else if (a instanceof Series) {
        return a.coefficients[0] < 0;
    }
    throw new Error('Unhandled case in isNegative');
}
function pow(a, b) {
    if (isNegative(a)) {
        var series = autodiff_context_1.defaultContext.seriesPool.allocate();
        for (var i = 0; i < series.coefficients.length; i++) {
            series.coefficients[i] = NaN;
        }
        return series;
    }
    return exp(multiply(b, log(a)));
}
exports.pow = pow;
function sinAndCos(aInput) {
    if (typeof aInput === 'number') {
        return [
            constantValue(Math.sin(aInput)),
            constantValue(Math.cos(aInput)),
        ];
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var sinResult = autodiff_context_1.defaultContext.seriesPool.allocate();
        sinResult.coefficients[0] = Math.sin(a[0]);
        var cosResult = autodiff_context_1.defaultContext.seriesPool.allocate();
        cosResult.coefficients[0] = Math.cos(a[0]);
        for (var k = 1; k < a.length; k++) {
            var sinConvolution = 0;
            var cosConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                sinConvolution += i * a[i] * cosResult.coefficients[k - i];
                cosConvolution += i * a[i] * sinResult.coefficients[k - i];
            }
            sinResult.coefficients[k] = sinConvolution / k;
            cosResult.coefficients[k] = -cosConvolution / k;
        }
        return [
            sinResult,
            cosResult,
        ];
    }
    throw new Error('Unhandled case in sinAndCos');
}
function sin(a) {
    var res = sinAndCos(a);
    res[1].freeToPool();
    return res[0];
}
exports.sin = sin;
function cos(a) {
    var res = sinAndCos(a);
    res[0].freeToPool();
    return res[1];
}
exports.cos = cos;
function tan(aInput) {
    if (typeof aInput === 'number') {
        return constantValue(Math.tan(aInput));
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var b = autodiff_context_1.defaultContext.seriesPool.allocate();
        b.coefficients[0] = 1 / (Math.cos(a[0]) * Math.cos(a[0]));
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.tan(a[0]);
        for (var k = 1; k < a.length; k++) {
            var hConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                hConvolution += i * a[i] * b.coefficients[k - i];
            }
            h.coefficients[k] = hConvolution / k;
            var bConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                bConvolution += i * h.coefficients[i] * h.coefficients[k - i];
            }
            b.coefficients[k] = 2 * bConvolution / k;
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in tan');
}
exports.tan = tan;
function asin(aInput) {
    if (typeof aInput === 'number') {
        if (Math.abs(aInput) >= 1) {
            console.warn("asin called with value " + aInput);
        }
        return constantValue(Math.asin(aInput));
    }
    else if (aInput instanceof Series) {
        if (Math.abs(aInput.coefficients[0]) >= 1) {
            console.warn("asin called with value " + aInput.coefficients[0]);
        }
        var a = aInput.coefficients;
        var b = autodiff_context_1.defaultContext.seriesPool.allocate();
        b.coefficients[0] = Math.sqrt(1 - a[0] * a[0]);
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.asin(a[0]);
        for (var k = 1; k < a.length; k++) {
            var hConvolution = 0;
            for (var i = 1; i < k; i++) {
                hConvolution += i * h.coefficients[i] * b.coefficients[k - i];
            }
            h.coefficients[k] = (a[k] - hConvolution / k) / b.coefficients[0];
            var bConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                bConvolution += i * h.coefficients[i] * a[k - i];
            }
            b.coefficients[k] = -bConvolution / k;
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in asin');
}
exports.asin = asin;
function acos(aInput) {
    if (typeof aInput === 'number') {
        if (Math.abs(aInput) >= 1) {
            console.warn("asin called with value " + aInput);
        }
        return constantValue(Math.acos(aInput));
    }
    else if (aInput instanceof Series) {
        if (Math.abs(aInput.coefficients[0]) >= 1) {
            console.warn("asin called with value " + aInput.coefficients[0]);
        }
        var a = aInput.coefficients;
        var b = autodiff_context_1.defaultContext.seriesPool.allocate();
        b.coefficients[0] = Math.sqrt(1 - a[0] * a[0]);
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.acos(a[0]);
        for (var k = 1; k < a.length; k++) {
            var hConvolution = 0;
            for (var i = 1; i < k; i++) {
                hConvolution += i * h.coefficients[i] * b.coefficients[k - i];
            }
            h.coefficients[k] = ((a[k] + hConvolution / k) / -b.coefficients[0]);
            var bConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                bConvolution += i * h.coefficients[i] * a[k - i];
            }
            b.coefficients[k] = bConvolution / k;
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in asin');
}
exports.acos = acos;
function atan(aInput) {
    if (typeof aInput === 'number') {
        return constantValue(Math.atan(aInput));
    }
    else if (aInput instanceof Series) {
        var a = aInput.coefficients;
        var b = autodiff_context_1.defaultContext.seriesPool.allocate();
        b.coefficients[0] = 1 + a[0] * a[0];
        var h = autodiff_context_1.defaultContext.seriesPool.allocate();
        h.coefficients[0] = Math.atan(a[0]);
        for (var k = 1; k < a.length; k++) {
            var hConvolution = 0;
            for (var i = 1; i < k; i++) {
                hConvolution += i * h.coefficients[i] * b.coefficients[k - i];
            }
            h.coefficients[k] = (a[k] - hConvolution / k) / b.coefficients[0];
            var bConvolution = 0;
            for (var i = 1; i < k + 1; i++) {
                bConvolution += i * a[i] * a[k - i];
            }
            b.coefficients[k] = 2 * bConvolution / k;
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in atan');
}
exports.atan = atan;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var tokenizer_1 = __webpack_require__(5);
var stream_1 = __webpack_require__(10);
var error_1 = __webpack_require__(1);
var parser_context_1 = __webpack_require__(11);
var pratt_parser_1 = __webpack_require__(12);
var NodeType;
(function (NodeType) {
    NodeType[NodeType["FUNCTION_CALL"] = 0] = "FUNCTION_CALL";
    NodeType[NodeType["IDENTIFIER"] = 1] = "IDENTIFIER";
    NodeType[NodeType["LITERAL"] = 2] = "LITERAL";
    NodeType[NodeType["PREFIX_OPERATOR"] = 3] = "PREFIX_OPERATOR";
    NodeType[NodeType["BINARY_OPERATOR"] = 4] = "BINARY_OPERATOR";
    NodeType[NodeType["GROUP"] = 5] = "GROUP";
})(NodeType = exports.NodeType || (exports.NodeType = {}));
function children(node) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR: return [node.firstArgument, node.secondArgument];
        case NodeType.FUNCTION_CALL: return [node.argument];
        case NodeType.IDENTIFIER: return [];
        case NodeType.LITERAL: return [];
        case NodeType.PREFIX_OPERATOR: return [node.argument];
        case NodeType.GROUP: return [node.argument];
    }
}
exports.children = children;
function toDebugString(node) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR:
            return "[" + toDebugString(node.firstArgument) + " " + node.token.value + " " + toDebugString(node.secondArgument) + "]";
        case NodeType.FUNCTION_CALL: return "[" + toDebugString(node["function"]) + "(" + toDebugString(node.argument) + ")]";
        case NodeType.IDENTIFIER: return "[" + node.token.value + "]";
        case NodeType.LITERAL: return "[" + node.token.value + "]";
        case NodeType.PREFIX_OPERATOR: return "[" + node.token.value + " " + toDebugString(node.argument) + "]";
        case NodeType.GROUP: return "[( " + toDebugString(node.argument) + " )]";
    }
}
exports.toDebugString = toDebugString;
function forEachNode(node, callback) {
    switch (node.type) {
        case NodeType.BINARY_OPERATOR: {
            forEachNode(node.firstArgument, callback);
            forEachNode(node.secondArgument, callback);
            break;
        }
        case NodeType.IDENTIFIER:
        case NodeType.LITERAL: {
            break;
        }
        case NodeType.FUNCTION_CALL:
        case NodeType.PREFIX_OPERATOR:
        case NodeType.GROUP: {
            forEachNode(node.argument, callback);
            break;
        }
    }
    callback(node);
}
exports.forEachNode = forEachNode;
function parseExpression(source) {
    source = source.trim();
    if (source.length === 0) {
        return {
            expression: null,
            userReadableError: ''
        };
    }
    var tokens = null;
    try {
        tokens = new stream_1.Stream(tokenizer_1.tokenize(source));
    }
    catch (err) {
        if (error_1.isParserError(err)) {
            return {
                expression: null,
                userReadableError: err.message
            };
        }
    }
    var ctx = new parser_context_1.ParserContext(tokens);
    var parser = new pratt_parser_1.ExpressionParser(ctx);
    parser.registerTerminal(tokenizer_1.TokenType.INT_LITERAL, function (token) {
        return {
            type: NodeType.LITERAL,
            token: token
        };
    });
    parser.registerTerminal(tokenizer_1.TokenType.FLOAT_LITERAL, function (token) {
        return {
            type: NodeType.LITERAL,
            token: token
        };
    });
    parser.registerTerminal(tokenizer_1.TokenType.IDENTIFIER, function (token) {
        return {
            type: NodeType.IDENTIFIER,
            token: token
        };
    });
    parser.registerPrefixUnaryOperator(tokenizer_1.TokenType.PLUS);
    parser.registerPrefixUnaryOperator(tokenizer_1.TokenType.MINUS);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.PLUS, pratt_parser_1.Precedence.SUM);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.MINUS, pratt_parser_1.Precedence.SUM);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.MULTIPLY, pratt_parser_1.Precedence.PRODUCT);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.DIVIDE, pratt_parser_1.Precedence.PRODUCT);
    parser.registerInfixBinaryOperator(tokenizer_1.TokenType.POW, pratt_parser_1.Precedence.EXPONENT);
    parser.registerParseletPrefix(tokenizer_1.TokenType.LEFT_PAREN, function (parser, _) {
        var peek = parser.peek();
        if (peek && peek.value === ')') {
            throw new error_1.ParserError(error_1.ErrorMsg.emptyParens);
        }
        var expr = parser.parseExpression(pratt_parser_1.Precedence.LOWEST);
        if (!expr) {
            throw new error_1.ParserError(error_1.ErrorMsg.genericFailure);
        }
        if (!parser.consumeIfPresent(tokenizer_1.TokenType.RIGHT_PAREN)) {
            throw new error_1.ParserError(error_1.ErrorMsg.missingRightParen);
        }
        return {
            type: NodeType.GROUP,
            token: null,
            argument: expr
        };
    });
    parser.registerParseletInfix(tokenizer_1.TokenType.LEFT_PAREN, pratt_parser_1.Precedence.CALL, function (parser, left, _) {
        var children = [];
        children.push(left);
        var expr = parser.parseExpression(pratt_parser_1.Precedence.LOWEST);
        if (!expr) {
            throw new error_1.ParserError(error_1.ErrorMsg.invalidArgument(left.token.value));
        }
        if (!parser.consumeIfPresent(tokenizer_1.TokenType.RIGHT_PAREN)) {
            throw new error_1.ParserError(error_1.ErrorMsg.missingRightParen);
        }
        if (left.type !== NodeType.IDENTIFIER) {
            throw new error_1.ParserError(error_1.ErrorMsg.nonIdentifierFunctionName);
        }
        return {
            type: NodeType.FUNCTION_CALL,
            token: null,
            "function": left,
            argument: expr
        };
    });
    var expression = null;
    var userReadableError = null;
    try {
        expression = parser.parseExpression(pratt_parser_1.Precedence.LOWEST);
    }
    catch (err) {
        if (error_1.isParserError(err)) {
            userReadableError = err.message;
        }
        else {
            userReadableError = error_1.ErrorMsg.genericFailure;
        }
    }
    if (!userReadableError && ctx.hasMoreTokens()) {
        userReadableError = error_1.ErrorMsg.genericFailure;
    }
    if (userReadableError != null) {
        return { expression: null, userReadableError: userReadableError };
    }
    return {
        expression: expression,
        userReadableError: userReadableError
    };
}
exports.parseExpression = parseExpression;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var factorial_1 = __webpack_require__(6);
var autodiff_context_1 = __webpack_require__(0);
function xEvaluatedAtPoint(value) {
    var series = autodiff_context_1.defaultContext.series2DPool.allocate();
    series.set(0, 0, value);
    series.set(1, 0, 1);
    return series;
}
exports.xEvaluatedAtPoint = xEvaluatedAtPoint;
function yEvaluatedAtPoint(value) {
    var series = autodiff_context_1.defaultContext.series2DPool.allocate();
    series.set(0, 0, value);
    series.set(0, 1, 1);
    return series;
}
exports.yEvaluatedAtPoint = yEvaluatedAtPoint;
function constantValue(value) {
    var series = autodiff_context_1.defaultContext.series2DPool.allocate();
    series.set(0, 0, value);
    return series;
}
exports.constantValue = constantValue;
var Series2D = (function () {
    function Series2D() {
        this.isFree = false;
        this.coefficients = [];
        this.size = -1;
        var globalDegree = autodiff_context_1.defaultContext.numDerivativesToCompute();
        this.size = globalDegree + 1;
        for (var y = 0; y <= globalDegree; y++) {
            for (var x = 0; x <= globalDegree; x++) {
                this.coefficients.push(0);
            }
        }
    }
    Series2D.prototype.set = function (x, y, value) {
        this.coefficients[y * this.size + x] = value;
    };
    Series2D.prototype.get = function (x, y) {
        return this.coefficients[y * this.size + x];
    };
    Series2D.prototype.debugPrint = function () {
        var s = '';
        for (var y = 0; y < this.size; y++) {
            for (var x = 0; x < this.size; x++) {
                s += this.coefficients[y * this.size + x] + " ";
            }
            s += "\n";
        }
        console.log(s);
    };
    Series2D.prototype.freeToPool = function () {
        autodiff_context_1.defaultContext.series2DPool.markFree(this);
    };
    return Series2D;
}());
exports.Series2D = Series2D;
function toValueAndDerivatives(s) {
    var derivatives = [];
    for (var y = 0; y < s.size; y++) {
        for (var x = 0; x < s.size; x++) {
            derivatives.push(s.get(x, y) * (factorial_1.factorial(x) * factorial_1.factorial(y)));
        }
    }
    return derivatives;
}
exports.toValueAndDerivatives = toValueAndDerivatives;
function add(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a + b);
    }
    else if (typeof a === 'number' && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocateCopy(b);
        res.coefficients[0] += a;
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocateCopy(a);
        res.coefficients[0] += b;
        return res;
    }
    else if (a instanceof Series2D && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocateCopy(a);
        for (var i = 0; i < a.coefficients.length; i++) {
            res.coefficients[i] += b.coefficients[i];
        }
        return res;
    }
    throw new Error('Unhandled case in add');
}
exports.add = add;
function negative(a) {
    if (typeof a === 'number') {
        return constantValue(-a);
    }
    else if (a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocateCopy(a);
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] *= -1;
        }
        return res;
    }
    throw new Error('Unhandled case in negative');
}
exports.negative = negative;
function subtract(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a - b);
    }
    else if (typeof a === 'number' && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a - b.coefficients[i];
        }
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] - b;
        }
        return res;
    }
    else if (a instanceof Series2D && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] - b.coefficients[i];
        }
        return res;
    }
    throw new Error('Unhandled case in subtract');
}
exports.subtract = subtract;
function convolve(a, b, boxWidth, boxHeight) {
    var total = 0;
    for (var x = 0; x < boxWidth; x++) {
        for (var y = 0; y < boxHeight; y++) {
            total += a.get(x, y) * b.get(boxWidth - 1 - x, boxHeight - 1 - y);
        }
    }
    return total;
}
exports.convolve = convolve;
var Coordinate;
(function (Coordinate) {
    Coordinate[Coordinate["X"] = 0] = "X";
    Coordinate[Coordinate["Y"] = 1] = "Y";
})(Coordinate || (Coordinate = {}));
function dConvolve(a, b, k_x, k_y) {
    if (k_x === 0 && k_y === 0) {
        throw new Error("dConvolve called with k_x === 0 and k_y === 0");
    }
    var k = [k_x, k_y];
    var p = (k_x === 0 ? Coordinate.Y :
        k_y === 0 ? Coordinate.X :
            k_x <= k_y ? Coordinate.X :
                Coordinate.Y);
    var k_p = k[p];
    var e_p = p === Coordinate.X ? [1, 0] : [0, 1];
    var total = 0;
    for (var x = e_p[0]; x <= k_x; x++) {
        for (var y = e_p[1]; y <= k_y; y++) {
            if (x === k_x && y === k_y) {
                continue;
            }
            var j = [x, y];
            var j_p = j[p];
            total += j_p * a.get(x, y) * b.get(k_x - x, k_y - y);
        }
    }
    var res = total / k_p;
    return res;
}
exports.dConvolve = dConvolve;
function multiply(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a * b);
    }
    else if (typeof a === 'number' && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a * b.coefficients[i];
        }
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] * b;
        }
        return res;
    }
    else if (a instanceof Series2D && b instanceof Series2D) {
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var size = a.size;
        for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++) {
                var h_ij = convolve(a, b, i + 1, j + 1);
                h.set(i, j, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in multiply');
}
exports.multiply = multiply;
function divide(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return constantValue(a / b);
    }
    else if (typeof a === 'number' && b instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a / b.coefficients[i];
        }
        return res;
    }
    else if (typeof b === 'number' && a instanceof Series2D) {
        var res = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < res.coefficients.length; i++) {
            res.coefficients[i] = a.coefficients[i] / b;
        }
        return res;
    }
    else if (a instanceof Series2D && b instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++) {
                if (i === 0 && j === 0) {
                    h.set(i, j, a.get(0, 0) / b.get(0, 0));
                    continue;
                }
                var a_ij = a.get(i, j);
                var b_00 = b.get(0, 0);
                var sum = convolve(h, b, i + 1, j + 1) - h.get(i, j) * b_00;
                var h_ij = (a_ij - sum) / b_00;
                h.set(i, j, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in divide');
}
exports.divide = divide;
function exp(a) {
    if (typeof a === 'number') {
        return constantValue(Math.exp(a));
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(x, y, Math.exp(a.get(0, 0)));
                    continue;
                }
                var h_ij = h.get(0, 0) * a.get(x, y) + dConvolve(a, h, x, y);
                h.set(x, y, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in exp');
}
exports.exp = exp;
function log(a) {
    if (typeof a === 'number') {
        if (a < 0) {
            throw new Error("log called with a negative number");
        }
        return constantValue(Math.log(a));
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(x, y, Math.log(a.get(0, 0)));
                    continue;
                }
                var h_ij = (a.get(x, y) - dConvolve(h, a, x, y)) / a.get(0, 0);
                h.set(x, y, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in log');
}
exports.log = log;
function sqrt(a) {
    if (typeof a === 'number') {
        return constantValue(Math.sqrt(a));
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(x, y, Math.sqrt(a.get(0, 0)));
                    continue;
                }
                var h_ij = (a.get(x, y) - 2 * dConvolve(h, h, x, y)) / (2 * h.get(0, 0));
                h.set(x, y, h_ij);
            }
        }
        return h;
    }
    throw new Error('Unhandled case in sqrt');
}
exports.sqrt = sqrt;
function isNegative(a) {
    if (typeof a === 'number') {
        return a < 0;
    }
    else if (a instanceof Series2D) {
        return a.get(0, 0) < 0;
    }
    throw new Error('Unhandled case in isNegative');
}
function pow(a, b) {
    if (isNegative(a)) {
        var series = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var i = 0; i < series.coefficients.length; i++) {
            series.coefficients[i] = NaN;
        }
        return series;
    }
    return exp(multiply(b, log(a)));
}
exports.pow = pow;
function sinAndCos(a) {
    if (typeof a === 'number') {
        return [
            constantValue(Math.sin(a)),
            constantValue(Math.cos(a)),
        ];
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var sinResult = autodiff_context_1.defaultContext.series2DPool.allocate();
        var cosResult = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    sinResult.set(x, y, Math.sin(a.get(0, 0)));
                    cosResult.set(x, y, Math.cos(a.get(0, 0)));
                    continue;
                }
                var s_ij = cosResult.get(0, 0) * a.get(x, y) + dConvolve(a, cosResult, x, y);
                sinResult.set(x, y, s_ij);
                var c_ij = -sinResult.get(0, 0) * a.get(x, y) - dConvolve(a, sinResult, x, y);
                cosResult.set(x, y, c_ij);
            }
        }
        return [
            sinResult,
            cosResult,
        ];
    }
    throw new Error('Unhandled case in sinAndCos');
}
function sin(a) {
    var res = sinAndCos(a);
    res[1].freeToPool();
    return res[0];
}
exports.sin = sin;
function cos(a) {
    var res = sinAndCos(a);
    res[0].freeToPool();
    return res[1];
}
exports.cos = cos;
function tan(a) {
    if (typeof a === 'number') {
        return constantValue(Math.tan(a));
    }
    else if (a instanceof Series2D) {
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var b = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    var a_00 = a.get(0, 0);
                    h.set(x, y, Math.tan(a_00));
                    b.set(x, y, 1 / (Math.cos(a_00) * Math.cos(a_00)));
                    continue;
                }
                var h_xy = b.get(0, 0) * a.get(x, y) + dConvolve(a, b, x, y);
                h.set(x, y, h_xy);
                var b_xy = 2 * (h.get(0, 0) * h.get(x, y) + dConvolve(h, h, x, y));
                b.set(x, y, b_xy);
            }
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in tan');
}
exports.tan = tan;
function asin(a) {
    if (typeof a === 'number') {
        if (Math.abs(a) >= 1) {
            console.warn("asin called with value " + a);
        }
        return constantValue(Math.asin(a));
    }
    else if (a instanceof Series2D) {
        if (Math.abs(a.coefficients[0]) >= 1) {
            console.warn("asin called with value " + a.coefficients[0]);
        }
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var b = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(0, 0, Math.asin(a.get(0, 0)));
                    b.set(0, 0, Math.cos(h.get(0, 0)));
                    continue;
                }
                var h_ij = (a.get(x, y) - dConvolve(h, b, x, y)) / b.get(0, 0);
                h.set(x, y, h_ij);
                var b_ij = -a.get(0, 0) * h.get(x, y) - dConvolve(h, a, x, y);
                b.set(x, y, b_ij);
            }
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in asin');
}
exports.asin = asin;
function acos(a) {
    if (typeof a === 'number') {
        if (Math.abs(a) >= 1) {
            console.warn("asin called with value " + a);
        }
        return constantValue(Math.acos(a));
    }
    else if (a instanceof Series2D) {
        if (Math.abs(a.coefficients[0]) >= 1) {
            console.warn("asin called with value " + a.coefficients[0]);
        }
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var b = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    h.set(0, 0, Math.acos(a.get(0, 0)));
                    b.set(0, 0, Math.sin(h.get(0, 0)));
                    continue;
                }
                var h_ij = (a.get(x, y) + dConvolve(h, b, x, y)) / -b.get(0, 0);
                h.set(x, y, h_ij);
                var b_ij = a.get(0, 0) * h.get(x, y) + dConvolve(h, a, x, y);
                b.set(x, y, b_ij);
            }
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in asin');
}
exports.acos = acos;
function atan(a) {
    if (typeof a === 'number') {
        return constantValue(Math.atan(a));
    }
    else if (a instanceof Series2D) {
        if (Math.abs(a.coefficients[0]) >= 1) {
            console.warn("asin called with value " + a.coefficients[0]);
        }
        var size = a.size;
        var h = autodiff_context_1.defaultContext.series2DPool.allocate();
        var b = autodiff_context_1.defaultContext.series2DPool.allocate();
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if (x === 0 && y === 0) {
                    var a_00 = a.get(0, 0);
                    h.set(x, y, Math.atan(a_00));
                    b.set(x, y, 1 + a_00 * a_00);
                    continue;
                }
                var h_ij = (a.get(x, y) - dConvolve(h, b, x, y)) / b.get(0, 0);
                h.set(x, y, h_ij);
                var b_ij = 2 * (a.get(0, 0) * a.get(x, y) + dConvolve(a, a, x, y));
                b.set(x, y, b_ij);
            }
        }
        b.freeToPool();
        return h;
    }
    throw new Error('Unhandled case in atan');
}
exports.atan = atan;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var error_1 = __webpack_require__(1);
var code_generator_1 = __webpack_require__(7);
var TokenType;
(function (TokenType) {
    TokenType[TokenType["NONE"] = 0] = "NONE";
    TokenType[TokenType["PLUS"] = 1] = "PLUS";
    TokenType[TokenType["MINUS"] = 2] = "MINUS";
    TokenType[TokenType["MULTIPLY"] = 3] = "MULTIPLY";
    TokenType[TokenType["DIVIDE"] = 4] = "DIVIDE";
    TokenType[TokenType["POW"] = 5] = "POW";
    TokenType[TokenType["LEFT_PAREN"] = 6] = "LEFT_PAREN";
    TokenType[TokenType["RIGHT_PAREN"] = 7] = "RIGHT_PAREN";
    TokenType[TokenType["FLOAT_LITERAL"] = 8] = "FLOAT_LITERAL";
    TokenType[TokenType["INT_LITERAL"] = 9] = "INT_LITERAL";
    TokenType[TokenType["IDENTIFIER"] = 10] = "IDENTIFIER";
    TokenType[TokenType["EOF"] = 11] = "EOF";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
function startsExpression(token) {
    var type = token.type;
    return (type === TokenType.IDENTIFIER ||
        type === TokenType.INT_LITERAL ||
        type === TokenType.FLOAT_LITERAL ||
        type === TokenType.LEFT_PAREN);
}
function endsExpression(token) {
    var type = token.type;
    var isSpecialFunction = (token.type === TokenType.IDENTIFIER &&
        code_generator_1.supportedFunctions.indexOf(token.value) !== -1);
    return (!isSpecialFunction &&
        type === TokenType.IDENTIFIER ||
        type === TokenType.INT_LITERAL ||
        type === TokenType.FLOAT_LITERAL ||
        type === TokenType.RIGHT_PAREN);
}
function insertImplicitMultiplications(tokens) {
    var result = [];
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (result.length === 0) {
            result.push(token);
            continue;
        }
        var prevToken = result[result.length - 1];
        var nextToken = token;
        if (endsExpression(prevToken) && startsExpression(nextToken)) {
            result.push({
                type: TokenType.MULTIPLY,
                value: '*'
            });
        }
        result.push(nextToken);
    }
    return result;
}
var tokenRegex = new RegExp("([0-9]+\\.[0-9]+|[0-9]+\\.|\\.[0-9]+|[0-9]+|[ \t\r\n]+|[-+*/^]|[a-zA-Z]+|[()])");
function tokenize(input) {
    var parts = input.split(tokenRegex);
    var tokens = [];
    for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (i % 2 === 0) {
            if (part.length !== 0) {
                throw new error_1.ParserError(error_1.ErrorMsg.invalidCharacter(part[0]));
            }
            continue;
        }
        if ((part[0] >= '0' && part[0] <= '9') || part[0] === '.' && part.length !== 0) {
            if (part.indexOf('.') === 0) {
                tokens.push({
                    type: TokenType.INT_LITERAL,
                    value: part
                });
            }
            else {
                tokens.push({
                    type: TokenType.FLOAT_LITERAL,
                    value: part
                });
            }
        }
        else if (part[0] === ' ' || part[0] === '\t' || part[0] === '\r' || part[0] === '\n') {
        }
        else if ((part[0] >= 'a' && part[0] <= 'z') || (part[0] >= 'A' && part[0] <= 'Z')) {
            tokens.push({
                type: TokenType.IDENTIFIER,
                value: part
            });
        }
        else if (part[0] === '-' || part[0] === '*' || part[0] === '/' || part[0] === '+' || part[0] === '^') {
            var type = (part[0] === '-' ? TokenType.MINUS :
                part[0] === '+' ? TokenType.PLUS :
                    part[0] === '/' ? TokenType.DIVIDE :
                        part[0] === '*' ? TokenType.MULTIPLY :
                            part[0] === '^' ? TokenType.POW :
                                TokenType.NONE);
            tokens.push({
                type: type,
                value: part
            });
        }
        else if (part[0] === '(' || part[0] === ')') {
            tokens.push({
                type: part[0] === '(' ? TokenType.LEFT_PAREN : TokenType.RIGHT_PAREN,
                value: part
            });
        }
        else {
            throw new error_1.ParserError(error_1.ErrorMsg.invalidCharacter(part[0]));
        }
    }
    return insertImplicitMultiplications(tokens);
}
exports.tokenize = tokenize;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var factorialValues = [
    1,
    1,
    2,
    6,
    24,
    120,
    720,
    5040,
    40320,
    362880,
    3628800,
    39916800,
    479001600,
];
function factorial(i) {
    if (i < factorialValues.length) {
        return factorialValues[i];
    }
    var result = factorial(i - 1) * i;
    if (factorialValues.length !== i) {
        throw new Error("Expected factorialValues length to be " + i);
    }
    factorialValues.push(result);
    return result;
}
exports.factorial = factorial;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var expression_parser_1 = __webpack_require__(3);
var series = __webpack_require__(2);
var series2D = __webpack_require__(4);
var autodiff_context_1 = __webpack_require__(0);
function getFunctionName(f) {
    return (f.name != null ?
        f.name :
        /function ([^(]*)/.exec(f + '')[1]);
}
exports.supportedFunctions = [
    getFunctionName(series.sqrt),
    getFunctionName(series.exp),
    getFunctionName(series.log),
    getFunctionName(series.sin),
    getFunctionName(series.cos),
    getFunctionName(series.tan),
    getFunctionName(series.asin),
    getFunctionName(series.acos),
    getFunctionName(series.atan),
];
var FunctionType;
(function (FunctionType) {
    FunctionType[FunctionType["SINGLE_VARIABLE"] = 0] = "SINGLE_VARIABLE";
    FunctionType[FunctionType["TWO_VARIABLE"] = 1] = "TWO_VARIABLE";
})(FunctionType = exports.FunctionType || (exports.FunctionType = {}));
function generateJavascriptForExpression(ctx, node) {
    switch (node.type) {
        case expression_parser_1.NodeType.BINARY_OPERATOR: {
            var op = node.token.value;
            var functionName = (op === '+' ? 's.' + getFunctionName(series.add) :
                op === '-' ? 's.' + getFunctionName(series.subtract) :
                    op === '*' ? 's.' + getFunctionName(series.multiply) :
                        op === '/' ? 's.' + getFunctionName(series.divide) :
                            op === '^' ? 's.' + getFunctionName(series.pow) :
                                null);
            if (!functionName) {
                throw new Error("Unhandled operator in toAutodiffSource");
            }
            return functionName + "(" + generateJavascriptForExpression(ctx, node.firstArgument) + ", " + generateJavascriptForExpression(ctx, node.secondArgument) + ")";
        }
        case expression_parser_1.NodeType.FUNCTION_CALL: {
            var functionName = node["function"].token.value;
            if (exports.supportedFunctions.indexOf(functionName) === -1) {
                throw new Error(functionName + " is not a supported function");
            }
            return "s." + functionName + "(" + generateJavascriptForExpression(ctx, node.argument) + ")";
        }
        case expression_parser_1.NodeType.IDENTIFIER: {
            var name_1 = node.token.value;
            var idx = ctx.independentVariables.indexOf(name_1);
            if (idx === -1) {
                throw new Error("That expression contains an identifier that isn't an independent variable: " + name_1);
            }
            switch (ctx.type) {
                case FunctionType.SINGLE_VARIABLE: {
                    return "s.variableEvaluatedAtPoint(" + name_1 + ")";
                }
                case FunctionType.TWO_VARIABLE: {
                    if (idx === 0) {
                        return "s.xEvaluatedAtPoint(" + name_1 + ")";
                    }
                    else if (idx === 1) {
                        return "s.yEvaluatedAtPoint(" + name_1 + ")";
                    }
                    else {
                        throw new Error("Invalid idx " + idx + " for function of type " + FunctionType[ctx.type]);
                    }
                }
            }
        }
        case expression_parser_1.NodeType.LITERAL: {
            return node.token.value;
        }
        case expression_parser_1.NodeType.PREFIX_OPERATOR: {
            if (node.token.value === '-') {
                return "s." + getFunctionName(series.negative) + "(" + generateJavascriptForExpression(ctx, node.argument) + ")";
            }
            else if (node.token.value === '+') {
            }
            else {
                throw new Error("Unhandled operator in toAutodiffSource");
            }
        }
        case expression_parser_1.NodeType.GROUP: {
            return generateJavascriptForExpression(ctx, node.argument);
        }
    }
}
exports.generateJavascriptForExpression = generateJavascriptForExpression;
var seriesAPI = {
    toValueAndDerivatives: series.toValueAndDerivatives,
    variableEvaluatedAtPoint: series.variableEvaluatedAtPoint,
    add: series.add,
    subtract: series.subtract,
    divide: series.divide,
    multiply: series.multiply,
    negative: series.negative,
    sqrt: series.sqrt,
    pow: series.pow,
    exp: series.exp,
    log: series.log,
    sin: series.sin,
    cos: series.cos,
    tan: series.tan,
    asin: series.asin,
    acos: series.acos,
    atan: series.atan
};
var series2DAPI = {
    toValueAndDerivatives: series2D.toValueAndDerivatives,
    xEvaluatedAtPoint: series2D.xEvaluatedAtPoint,
    yEvaluatedAtPoint: series2D.yEvaluatedAtPoint,
    add: series2D.add,
    subtract: series2D.subtract,
    divide: series2D.divide,
    multiply: series2D.multiply,
    negative: series2D.negative,
    sqrt: series2D.sqrt,
    pow: series2D.pow,
    exp: series2D.exp,
    log: series2D.log,
    sin: series2D.sin,
    cos: series2D.cos,
    tan: series2D.tan,
    asin: series2D.asin,
    acos: series2D.acos,
    atan: series2D.atan
};
function buildSingleVariableAutodiffFunctionForExpression(expression, independentVariable) {
    var ctx = {
        type: FunctionType.SINGLE_VARIABLE,
        independentVariables: [independentVariable]
    };
    var src = generateJavascriptForExpression(ctx, expression);
    var wrappedFunc = new Function(independentVariable, "s", "return s." + getFunctionName(series.toValueAndDerivatives) + "(" + src + ")");
    return function (x) {
        var res = null;
        autodiff_context_1.defaultContext.seriesPool.trackAndReleaseAllocations(function () {
            res = wrappedFunc(x, seriesAPI);
        });
        return res;
    };
}
exports.buildSingleVariableAutodiffFunctionForExpression = buildSingleVariableAutodiffFunctionForExpression;
function buildTwoVariableAutodiffFunctionForExpression(expression, independentVariables) {
    var ctx = {
        type: FunctionType.TWO_VARIABLE,
        independentVariables: independentVariables
    };
    var src = generateJavascriptForExpression(ctx, expression);
    var wrappedFunc = new Function(independentVariables[0], independentVariables[1], "s", "return s." + getFunctionName(series2D.toValueAndDerivatives) + "(" + src + ")");
    return function (x, y) {
        var res = null;
        autodiff_context_1.defaultContext.series2DPool.trackAndReleaseAllocations(function () {
            res = wrappedFunc(x, y, series2DAPI);
        });
        return res;
    };
}
exports.buildTwoVariableAutodiffFunctionForExpression = buildTwoVariableAutodiffFunctionForExpression;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var series_1 = __webpack_require__(2);
exports.toValueAndDerivatives = series_1.toValueAndDerivatives;
var code_generator_1 = __webpack_require__(7);
var expression_parser_1 = __webpack_require__(3);
var autodiff_context_1 = __webpack_require__(0);
function setNumberOfDerivativesToCompute(n) {
    autodiff_context_1.defaultContext.setNumberOfDerivativesToCompute(n);
}
exports.setNumberOfDerivativesToCompute = setNumberOfDerivativesToCompute;
function compileFunction(independentVariable, exprString) {
    var _a = expression_parser_1.parseExpression(exprString), expression = _a.expression, userReadableError = _a.userReadableError;
    if (userReadableError) {
        throw new Error(userReadableError);
    }
    return code_generator_1.buildSingleVariableAutodiffFunctionForExpression(expression, independentVariable);
}
exports.compileFunction = compileFunction;
function compileTwoVariableFunction(firstIndependentVariable, secondIndependentVariable, exprString) {
    var _a = expression_parser_1.parseExpression(exprString), expression = _a.expression, userReadableError = _a.userReadableError;
    if (userReadableError) {
        throw new Error(userReadableError);
    }
    return code_generator_1.buildTwoVariableAutodiffFunctionForExpression(expression, [
        firstIndependentVariable,
        secondIndependentVariable,
    ]);
}
exports.compileTwoVariableFunction = compileTwoVariableFunction;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Pool = (function () {
    function Pool(_newT, _clearT, _copyT) {
        this._newT = _newT;
        this._clearT = _clearT;
        this._copyT = _copyT;
        this._free = [];
        this._trackedAllocations = null;
    }
    Pool.prototype.trackAndReleaseAllocations = function (callback) {
        this._trackedAllocations = [];
        callback();
        for (var i = 0; i < this._trackedAllocations.length; i++) {
            if (!this._trackedAllocations[i].isFree) {
                this.markFree(this._trackedAllocations[i]);
            }
        }
        this._trackedAllocations = null;
    };
    Pool.prototype.allocate = function () {
        var res = null;
        if (this._free.length > 0) {
            res = this._free.pop();
            this._clearT(res);
        }
        else {
            res = this._newT();
        }
        if (this._trackedAllocations) {
            this._trackedAllocations.push(res);
        }
        res.isFree = false;
        return res;
    };
    Pool.prototype.allocateCopy = function (s) {
        var copy = this.allocate();
        this._copyT(copy, s);
        copy.isFree = false;
        return copy;
    };
    Pool.prototype.markFree = function (series) {
        series.isFree = true;
        this._free.push(series);
    };
    Pool.prototype.forgetFreeElements = function () {
        this._free = [];
    };
    return Pool;
}());
exports.Pool = Pool;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Stream = (function () {
    function Stream(_values) {
        this._values = _values;
        this._index = 0;
    }
    Stream.prototype.next = function () {
        var value = this.peek();
        this._index++;
        return value;
    };
    Stream.prototype.peek = function () {
        var value = null;
        if (this._index < this._values.length) {
            value = this._values[this._index];
        }
        return value;
    };
    Stream.prototype.isDone = function () {
        return this._index >= this._values.length;
    };
    return Stream;
}());
exports.Stream = Stream;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var tokenizer_1 = __webpack_require__(5);
var ParserContext = (function () {
    function ParserContext(_tokens) {
        this._tokens = _tokens;
    }
    ParserContext.prototype.hasMoreTokens = function () {
        return !this._tokens.isDone();
    };
    ParserContext.prototype.advanceToNextTokenOfType = function (tokenType) {
        while (this.peek().type !== tokenType && this.peek().type !== tokenizer_1.TokenType.EOF) {
            this.next();
        }
        return this.peek().type !== tokenizer_1.TokenType.EOF;
    };
    ParserContext.prototype.consumeIfType = function (tokenType) {
        if (this.peek().type === tokenType) {
            return this.next();
        }
        return null;
    };
    ParserContext.prototype.consumeIf = function (predicate) {
        var token = this.peek();
        if (predicate(token)) {
            return this._tokens.next();
        }
        return null;
    };
    ParserContext.prototype.peek = function () {
        var token = this._tokens.peek();
        return token ? token : { type: tokenizer_1.TokenType.EOF, value: null };
    };
    ParserContext.prototype.next = function () {
        var token = this.peek();
        this._tokens.next();
        return token;
    };
    return ParserContext;
}());
exports.ParserContext = ParserContext;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var error_1 = __webpack_require__(1);
var expression_parser_1 = __webpack_require__(3);
var Precedence;
(function (Precedence) {
    Precedence[Precedence["LOWEST"] = 0] = "LOWEST";
    Precedence[Precedence["SUM"] = 1] = "SUM";
    Precedence[Precedence["PRODUCT"] = 2] = "PRODUCT";
    Precedence[Precedence["EXPONENT"] = 3] = "EXPONENT";
    Precedence[Precedence["PREFIX"] = 4] = "PREFIX";
    Precedence[Precedence["CALL"] = 5] = "CALL";
})(Precedence = exports.Precedence || (exports.Precedence = {}));
var ExpressionParser = (function () {
    function ExpressionParser(_ctx) {
        this._ctx = _ctx;
        this._parselets = Object.create(null);
    }
    ExpressionParser.prototype.registerParseletPrefix = function (tokenType, prefixParse) {
        this.getParselet(tokenType).prefixParse = prefixParse;
    };
    ExpressionParser.prototype.registerParseletInfix = function (tokenType, infixPrecedence, infixParse) {
        this.getParselet(tokenType, infixPrecedence).infixParse = infixParse;
    };
    ExpressionParser.prototype.registerTerminal = function (tokenType, createNode) {
        this.registerParseletPrefix(tokenType, function (_, token) {
            return createNode(token);
        });
    };
    ExpressionParser.prototype.registerPrefixUnaryOperator = function (tokenType) {
        this.registerParseletPrefix(tokenType, function (parser, token) {
            var operand = parser.parseExpression(Precedence.PREFIX);
            if (!operand) {
                throw new error_1.ParserError(error_1.ErrorMsg.operatorMissingRightOperand(token.value));
            }
            return {
                type: expression_parser_1.NodeType.PREFIX_OPERATOR,
                token: token,
                argument: operand
            };
        });
    };
    ExpressionParser.prototype.registerInfixBinaryOperator = function (tokenType, precedence) {
        this.registerParseletInfix(tokenType, precedence, function (parser, left, token) {
            var right = parser.parseExpression(precedence);
            if (!right) {
                throw new error_1.ParserError(error_1.ErrorMsg.operatorMissingRightOperand(token.value));
            }
            return {
                type: expression_parser_1.NodeType.BINARY_OPERATOR,
                token: token,
                firstArgument: left,
                secondArgument: right
            };
        });
    };
    ExpressionParser.prototype.getParselet = function (tokenType, infixPrecedence) {
        if (infixPrecedence === void 0) { infixPrecedence = null; }
        if (!this._parselets[tokenType]) {
            this._parselets[tokenType] = {
                prefixParse: null,
                infixPrecedence: null,
                infixParse: null
            };
        }
        var parselet = this._parselets[tokenType];
        if (infixPrecedence !== null) {
            parselet.infixPrecedence = infixPrecedence;
        }
        return parselet;
    };
    ExpressionParser.prototype.peek = function () {
        return this._ctx.peek();
    };
    ExpressionParser.prototype.consumeIfPresent = function (tokenType) {
        if (this._ctx.peek().type === tokenType) {
            this._ctx.next();
            return true;
        }
        return false;
    };
    ExpressionParser.prototype.peekTokenPrecedence = function () {
        var token = this._ctx.peek();
        if (!token) {
            return Precedence.LOWEST;
        }
        var parselet = this._parselets[token.type];
        return (parselet && parselet.infixPrecedence != null ?
            parselet.infixPrecedence :
            Precedence.LOWEST);
    };
    ExpressionParser.prototype.parseExpression = function (precedence) {
        var token = this._ctx.peek();
        if (!token) {
            throw Error('Missing token in parseExpression');
        }
        var parselet = this._parselets[token.type];
        if (!parselet || !parselet.prefixParse) {
            return null;
        }
        this._ctx.next();
        var left = parselet.prefixParse(this, token);
        while (precedence < this.peekTokenPrecedence()) {
            token = this._ctx.next();
            var parselet_1 = this._parselets[token.type];
            if (!parselet_1 || !parselet_1.infixParse) {
                throw Error('Missing parselet or infix parselet');
            }
            left = parselet_1.infixParse(this, left, token);
        }
        return left;
    };
    return ExpressionParser;
}());
exports.ExpressionParser = ExpressionParser;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(8);


/***/ })
/******/ ]);
});